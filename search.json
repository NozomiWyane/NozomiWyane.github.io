[{"title":"激光SLAM学习 点云特征提取与位姿优化","date":"2022-10-27T07:59:19.173Z","url":"/2022/10/27/SLAM/Geometry_feature/","tags":[["Deep learning","/tags/Deep-learning/"],["SLAM","/tags/SLAM/"],["特征提取","/tags/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/"]],"categories":[["undefined",""]],"content":"点云线面特征提取参考博客：[LOAM论文和程序代码的解读] 按线数分割当给出的一帧点云中，所给的点不知道它属于哪根线时，可以根据激光点的坐标，计算该束激光相比于雷达水平面的倾角,根据内参倾角就可以计算得到： P = (x,y,z) \\\\ w = arctan \\frac{z}{\\sqrt{x^2+y^2}} 计算曲率根据同一条线面上前后各5个点与当前点的长度（长度指激光点到雷达的距离），计算曲率大小。 c= \\frac{1}{\\| x\\|}\\| \\sum_{i} (X - X_i) \\|这样我们可以在同一个平面内，按照曲率大小进行特征提取。 1.曲率特别大的点（sharp)这种情况下，这个线打到的实体表面应该如下图：可以由图看见，作者直观地展示曲率的大小，我用直线表示在各个点上，直线高度与曲率c成正比。越尖锐的点曲率越大，在直线上的点曲率则是，远比左右点的距离小，得到的曲率值是特别大的。而对于平面来说，他们之间的差距很小甚至没有，所以能得到其曲率为0。同样地，在不规则平面内可以显示：根据曲率值的大小，可以对点进行分类。论文中分成两类：曲率大的就是角点(sharp)，曲率小的是平面点（flat），或者说一条线上的点，作为特征进行匹配。这些特征要如何用于位姿估计和优化？ 基于线面特征的位姿优化1. 帧间关联1）点云位姿转换对于相邻两帧之间的相对位姿，即第k+1帧与第k帧的相对位姿为 T = \\begin{bmatrix} R & t \\\\ 0 & 1 \\end{bmatrix}从第k+1帧中的点#p_i#转到第k帧坐标系： \\tilde{p_i} = Rp_i+t2）特征关联对于所有的特征点，由于一帧内的点是在不同时间内扫出来的，将一帧内所有点先重投影到每一帧的最后的时刻，这样就能得到一帧中所有特征点的信息。特征点分为两类： 对于角点，一般在转折线上（例如卧室里的墙角），要计算它到折线的距离。作者认为，可以有如下假设：角点是雷达某个线束与物理世界两个平面夹角相交时的采样，那么这个线束相邻的雷达扫描线束也会与这个平面夹角相交，所以这个平面夹角的直线可以用前后两次扫描的角点进行标识。角点#p_i}#在上一帧的坐标系转换为#\\tilde{p_i}#,在这个坐标系中找离它最近的线特征点a，并在相邻的线上再找一个线特征点b。这两个点就可以确定直线方程，就能够计算激光雷达到该直线的距离。我的理解是这样做可以把角点作为参考点，而这个线特征点a是当前的位置，线特征点b是上一帧的位置，利用环境稳定的特征点作为参考得到计算 对于平面点，一般在比较平坦的表面上（例如墙面），要计算它到平面的距离。与角点是差不多的，首先找上一帧中最近邻的平面点，之后在同一个扫描线数和不同的线束上各提取一个平面点，这样共得到了3个不共线的平面点，唯一确定了平面，从而计算平面点到平面的距离。 2. 残差函数1）线特征由上图和我们的计算函数可知，我们对于点云中的#\\tilde{p_i}#到该直线的距离可以由下式计算 d_{\\epislon} = \\frac{|(\\tilde{p_i}-p_j)\\times(\\tilde{p_i}-p_l)|}{|p_l-p_j|}而对于点到平面的距离 d_{H} = (\\tilde{p_i}-p_j) \\ \\frac{|(p_l-p_j)\\times(p_m-p_j)|}{|(p_l-p_j)\\times(p_m-p_j)|}根据这个特征，我们可以构造关于待求变量（T，相对位姿转换矩阵）的残差函数并建立其优化目的，对问题模型进行建立."},{"title":"激光SLAM学习 几何基础","date":"2022-10-27T06:23:32.157Z","url":"/2022/10/27/SLAM/Geometry/","tags":[["Deep learning","/tags/Deep-learning/"],["SLAM","/tags/SLAM/"],["几何","/tags/%E5%87%A0%E4%BD%95/"]],"categories":[["undefined",""]],"content":"几何基础在应用激光雷达算法之前，我们先对几何基础进行学习。 向量运算及其几何意义 内积内积，即数量积，点乘。定义如下： \\vec{a} = (x_1,y_1,z_1) \\vec{b} = (x_2,y_2,z_2) \\vec{a} \\cdot \\vec{b} = x_1x_2 + y_1y_2 + z_1z_2对于几何意义，则是a在b上的投影后的积： \\vec{a} \\cdot \\vec{b} = |{a}||{b}|\\cos{\\theta} 外积外积，即向量积，叉乘。定义如下： \\vec{a} = (x_1,y_1,z_1) \\\\ \\vec{b} = (x_2,y_2,z_2)\\\\ \\vec{a} \\times \\vec{b} = \\begin{bmatrix} i & j & k \\\\ x_1 & y_1 & z_1 \\\\ x_2 & y_2 & z_2 \\end{bmatrix}x_1x_2 + y_1y_2 + z_1z_2 \\\\ = (y_1z_2 - y_2z_1)i - (x_1z_2 - x_2z_1)j + (x_1y_2-x_2y_1)k对于几何意义，外积的模长则是a和b组成的平行四边形的面积： \\vec{a} \\times \\vec{b} = \\underbrace{|{\\vec{a}}|\\sin{\\theta}}_{高} |{\\vec{b}}| 外积的方向满足右手定则，由a和b张成平面的（单位）法向量n为： \\vec{n} = \\frac{\\vec{a} \\times \\vec{b} }{|\\vec{a} \\times \\vec{b}|} 微分性质对于内积微分有： \\frac{\\partial{\\vec{a} \\cdot \\vec{b}}}{\\partial{\\vec{a}}} = \\vec{b}对于外积微分有： \\vec{a} \\times \\vec{b} = \\hat{a} b其中[a]^为a的反对称矩阵。 \\hat{a} b = \\hat{[b]}a \\\\ \\frac{\\partial{\\hat{a} b}}{\\partial{\\vec{a}}} = -\\hat{[b]} 线面特征运算 点到直线的距离（平面内）点A到直线BC的距离为平行四边形面积除以对角线长度： |\\vec{AD}| = \\frac{|\\vec{AB} \\times \\vec{AC}|}{|\\vec{BC}|} 点到平面距离（空间内）首先要求出平面BCD的法向量，再求出该点与该平面与相交的线在法向量上的投影平面BCD的单位法向量为： \\vec{n} = \\frac{\\vec{BC} \\times \\vec{BD} }{|\\vec{BC} \\times \\vec{BD}|}然后点A到平面BCD的距离就可以由AB到法向量的投影求得： \\vec{AE} =|\\vec{AB}|\\cos{\\theta} = \\vec{AB} \\cdot \\vec{n} "},{"title":"激光SLAM学习 点云畸变补偿","date":"2022-10-25T13:05:12.337Z","url":"/2022/10/25/SLAM/Distortion/","tags":[["Deep learning","/tags/Deep-learning/"],["SLAM","/tags/SLAM/"],["畸变补偿","/tags/%E7%95%B8%E5%8F%98%E8%A1%A5%E5%81%BF/"]],"categories":[["undefined",""]],"content":"点云畸变补偿激光雷达通过发射激光束来测量周围环境物体的距离和方位，从而判断车辆与障碍物的相对位置。当其发射的激光束足够多时，这一个个的激光点将汇集成一片点云，勾勒出其所处的三维环境信息，这便是我们常说的点云数据。对于多数激光雷达而言，尽管激光的发射与接收很快，但构成点云的每一个点仍非同一时刻生成的。一般我们会将100ms (对应典型值10Hz) 内累积的数据作为一帧点云输出。若在这100ms内，激光雷达本体或安装所在的机体发生绝对位置的变化，那么此帧点云中每一个点的坐标系就是不同的。直观上看，这一帧点云数据就会发生一定的“变形”，不能真实对应所探测到的环境信息，类似于拍照时手抖了，拍出来的照片就会糊。这便是激光雷达的自运动畸变。引自知乎Livox 览沃激光雷达 自运动畸变由于激光雷达自身所在的载体坐标系发生改变时，会导致激光雷达坐标系运动，在一定时间内扫描的一圈不能闭合，包括旋转和平移，如下图：由图可知，平移会导致圆形的破坏，导致圆心的偏移；而旋转会导致部分的点相对于起始角有角度偏移。二者均会导致获得的点云产生畸变，在输入到SLAM前，对其纠正是必要的。 补偿方法需要对每个激光点坐标作补偿，补偿量为激光点原点（当时雷达的坐标）相对于起始时刻的变化，即计算时刻0（起始时刻）到时刻i（当前时刻）发生的旋转和平移变化。数学表示如下： 假设一帧点云中，起始时刻0雷达的位姿为： T_0 = \\begin{bmatrix} R_0 & t_0 \\\\ 0 & 1 \\end{bmatrix}在时刻i（第i帧），雷达的位姿为： T_i = \\begin{bmatrix} R_i & t_i \\\\ 0 & 1 \\end{bmatrix}第i个激光点的坐标为: P_i = \\begin{bmatrix} p_{ix} & p_{iy} & p_{iz} \\end{bmatrix}经过位姿测量，补偿后的激光点的坐标为: \\vec{P_i} = T_0^{-1}T_i P_i也可以通过平均角速度$w$和速度$v$来算出来对应的$R_i$和$t_i$: R_i = w d_{time} \\\\ t_i = v d_{time}该位姿变化可以使用角速度、线速度的输入，或者imu、编码器等外接传感器来计算其相对位姿，也可以使用slam的相对位姿（效果稍差）。 "},{"title":"激光SLAM学习 正态分布变换NDT","date":"2022-10-24T14:57:19.385Z","url":"/2022/10/24/SLAM/NDT/","tags":[["Deep learning","/tags/Deep-learning/"],["SLAM","/tags/SLAM/"],["NDT","/tags/NDT/"]],"categories":[["undefined",""]],"content":"正态分布变换 Normal Distribution Transformation正态分布是用于描述一个变量的概率分布中的一种，在SLAM中是将点云的分布用正态分布进行描述。其基本流程如下图：其概率指的是待匹配点云与目标点云他们栅格的点统计的数目，计算了均值，协方差就可构建其相关的正态分布。 问题描述 基于NDT的问题描述和输入描述如下：点集： X = \\{x_1,x_2, ... , x_{N_x}\\}Y = \\{y_1,y_2, ... , y_{N_y}\\}其中X和Y是原始点云的子集，选取的是两个点集中能够互相关联的点集，$N_x = N_y$目标函数： max \\Psi =max \\prod_{i=1}^{N_y} f(X,T(p,y_i))目标函数由原来的点到点之间的欧式距离计算变为了联合概率。f代表的是概率密度函数，X代表的是待匹配点集,$T(P,Y_i)$代表的是其空间转换函数，其中p代表的姿态变换，用于对$y_i$进行移动。 对于2D模型：$p = p_3 = [t_x t_y \\phi _z]^T$ 对于3D模型：$p = p_6 = [t_x t_y t_z \\phi _x \\phi _y \\phi _z]^T$ 概率模型计算对于点云概率分布的计算，需要计算其均值和协方差。 均值： \\mu = \\frac{1}{N_x} \\sum_{i=1}^{N_x} x_i \\\\ 协方差： E = \\frac{N_x -1}{1} \\sum_{i=1}^{N_x} (x_i - \\mu) (x_i - \\mu)^T对于目标函数中的预测的位姿，根据初始值R和t对点进行旋转平移得到Y,获得在同一坐标系下的X和Y。 预测值: $y\\prime _i = T(p,y_i) = Ry_i + t$根据定义即可计算各点的联合概率： f(X,y\\prime _i) = \\frac{1} {\\sqrt{2\\pi}\\sqrt{|E|}} exp(-\\frac{(y\\prime _i-\\mu)^TE^{-1}(y\\prime _i-\\mu)}{2})所有点的联合概率： \\begin{equation} \\begin{split} \\Phi &= \\prod_{i=1}^{N_y} f(X,T(p,y_i)) \\\\ &= \\prod_{i=1}^{N_y} \\frac{1} {\\sqrt{2\\pi}\\sqrt{|E|}} exp(-\\frac{(y\\prime _i-\\mu)^TE^{-1}(y\\prime _i-\\mu)}{2}) \\\\ \\end{split} \\nonumber \\end{equation}取对数,最后一项为常数： ln \\Phi = \\sum_{i=1}^{N_y}(-\\frac{(y\\prime _i-\\mu)^TE^{-1}(y\\prime _i-\\mu)}{2}+ln(\\frac{1} {\\sqrt{2\\pi}\\sqrt{|E|}}))所以目标函数则可以转化为： max \\Psi = max ln\\Psi = min\\sum_{i=1}^{N_y}(y\\prime _i-\\mu)^TE^{-1}(y\\prime _i-\\mu)由该目标函数中可以定义出残差函数$f_i(p)=y\\prime _i-\\mu$,根据高斯牛顿法进行计算，残差函数关于待求参数的雅可比，便可迭代优化。 J_i = \\frac{dp}{df_i(p)}这里的p其实就是前面的姿态变换矩阵，对其求偏导，对于2D模型的求导过程如下： p = p_3 = [t_x t_y \\phi _z]^T \\\\ \\begin{equation} \\begin{split} y\\prime _i &= T(p,y_i) \\\\ &= \\begin{bmatrix} cos \\phi _z & -sin \\phi _z \\\\ sin \\phi _z & cos \\phi _z \\end{bmatrix} y_i + \\begin{bmatrix} t_x \\\\ t_y \\end{bmatrix} \\end{split} \\nonumber \\end{equation}\\\\ 雅可比矩阵J_i = \\begin{bmatrix} 1 & 0 & -y_{i1} sin \\phi _z - -y_{i2} cos \\phi _z\\\\ 0 & 1 & y_{i1} cos \\phi _z - -y_{i2} sin \\phi _z \\end{bmatrix} 三维场景下同样能求出对应的雅可比矩阵，这里用图进行表示： 代码："},{"title":"激光SLAM学习 迭代最近邻点算法","date":"2022-10-24T07:51:41.516Z","url":"/2022/10/24/SLAM/ICP/","tags":[["AI","/tags/AI/"],["Deep learning","/tags/Deep-learning/"],["SLAM","/tags/SLAM/"]],"categories":[["undefined",""]],"content":"迭代最近邻点算法 Iterative Closest Point该方法为最简单暴力的匹配算法，根据问题描述中的目标函数，对目标函数进行推导。 问题描述 前端里程计的问题描述和输入描述如下：点集： X = \\{x_1,x_2, ... , x_{N_x}\\}Y = \\{y_1,y_2, ... , y_{N_y}\\}其中X和Y是原始点云的子集，选取的是两个点集中能够互相关联的点集，$N_x = N_y$目标函数： minE(R,T)=min\\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|x_i - Ry_i - t\\|^2其中R和T分别为旋转矩阵和平移矩阵，E代表均方差。求得R和T使得他们的欧式距离的均方差E最小，这是最基本的目标函数。 （1）基于奇异值分解（SVD）的ICPSVD的方法首先第一步将加了几部分进来，进行转变 \\begin{equation} \\begin{split} E(R,T) &= \\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|x_i - Ry_i - t + -u_x + Ru_y +u_x - Ru_y \\|^2 \\\\ &= \\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|x_i -u_x - R(y_i - u_y)+ (u_x - Ru_y - t )\\|^2 \\\\ & 这里根据平方差公式展开\\\\ &= \\frac{1}{N_y} \\sum_{i=1}^{N_y} (\\|x_i -u_x - R(y_i - u_y)\\|^2 + \\|(u_x - Ru_y - t )\\|^2 \\\\ & +2(x_i -u_x - R(y_i - u_y))^T(u_x - Ru_y - t )) \\end{split} \\nonumber \\end{equation}其中$u_x$和$u_y$分别是点集X和Y的质心，即 u_x = \\frac{1}{N_x} \\sum_{i=1}^{N_x} x_i \\\\ u_y = \\frac{1}{N_y} \\sum_{i=1}^{N_y} y_i结合前面的求和可知$x_i -u_x - R(y_i - u_y)$项为0，E(R,T)变为如下 E(R,T) = \\frac{1}{N_y} \\sum_{i=1}^{N_y} (\\|x_i -u_x - R(y_i - u_y)\\|^2 + \\|(u_x - Ru_y - t )\\|^2)将其拆分为两部分： E_1(R,T) = \\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|x_i -u_x - R(y_i - u_y)\\|^2 \\\\ E_2(R,T) = \\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|(u_x - Ru_y - t )\\|^2 由$E_2$的性质可知，对于任意的一个R，都可以找到一个t使得$u_x - Ru_y - t = 0$，所以不需要求$E_2$，只需要求$E_1$，得到R之后，自然得到t。对$E_1$进行推导: \\begin{equation} \\begin{split} E\\prime _1(R,T) &= \\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|x_i -u_x - R(y_i - u_y)\\|^2 \\\\ &= \\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|x\\prime _i - R(y\\prime _i)\\|^2 \\\\ &= \\frac{1}{N_y} \\sum_{i=1}^{N_y} ( x\\prime _i^T x\\prime _i+ y\\prime _i^T R^T Ry\\prime _i - 2x\\prime _i^T Ry\\prime _i) \\end{split} \\nonumber \\end{equation} 该式中，第一项与R无关，而第二项二单位阵，只与第三项有关，则目标函数变为： \\begin{equation} \\begin{split} E\\prime _1(R,t) &= arg\\underset {R}{max} \\sum_{i=1}^{N_y} x\\prime _i^T Ry\\prime _i \\\\ &= arg\\underset {R}{max} \\sum_{i=1}^{N_y} Trace(x\\prime _i^T Ry\\prime _i) \\\\ & 由 trace(AB) = trace(BA) \\\\ &= arg\\underset {R}{max} \\sum_{i=1}^{N_y} Trace(Ry\\prime _i x\\prime _i^T ) \\\\ &= arg\\underset {R}{max} Trace(RH) \\\\ 其中H = \\sum_{i=1}^{N_y} y\\prime _i x\\prime _i^T \\end{split} \\nonumber \\end{equation} 至此，需要对该矩阵转变为正定矩阵，并进行分解定理：若存在正定矩阵$AA^T$,一定存在任意正交矩阵B，使得$Trace(AA^T) \\geq Trace(BAA^T) $意义：若能找到R，使得RH变为正定矩阵，则找到最大值，满足目标函数 对H进行奇异值分解： H = UEV^T = y\\prime _i x\\prime _i^T\\\\ 若R = VU^T \\\\ 则RH = VU^T UE V^T =VE V^T = VE^{\\frac 12} (VE^{\\frac 12})^T在这里其实由H的定义可知U即$y\\prime _i$,V即$x\\prime _i^T$。 接下来我们对实现代码进行讲解 （2）基于凸优化的ICP首先对凸优化本身进行一些基础讲解，它对什么样的问题有进行什么操作？ 凸优化基础 优化任务的目标凸优化是对n维的变量$x^* \\in \\frak{R} ^n$，使得损失函数F(x)取得局部最小值： \\underset {x}{min} F(x) = \\frac 12 \\|f(x) \\|_2^2局部最小值指对任意的$|x - x^ | &lt; \\sigma $，都有$F(x^) \\leq F(x) $, 其f(x)是参残差函数，这个残差函数可以代表预测和观测 也可以是匹配的时候的点的距离 可以由多个残差函数组成。 迭代方法的思路 给定初值$x_0$； 对于第k次迭代，寻找增量$\\Delta x_k$，使得$|x_k + \\Delta x_k |_2^2$达到极小值; 如果达到足够小的值，则停止；否则返回第2步，继续迭代。 迭代下降求解优化的方法对损失函数进行泰勒展开可以得到： F(x + \\Delta x) \\approx F(x) + J \\Delta x + \\frac 12 \\Delta x^T H \\Delta x其中J为X的一阶导（雅可比矩阵，Jacobian），H为X的二阶导（海森矩阵，Hessian） 最速下降法 只保留一阶泰勒展开，增量$\\Delta x^* = -J^T$,沿梯度的反方向取增量，保证损失函数减少。优点: 简单、迭代方便缺点：精度有限、接近目标值时会下降变慢 牛顿法 保留二阶泰勒展开，增量方程为 \\Delta x^* = argmin (F(x) + J\\Delta x + \\frac 12 \\Delta x^TH\\Delta x求其最小值即求该方程的导数为0，即 J^T + H\\Delta x = 0 \\Rightarrow H\\Delta x = -J^T优点: 更精确，每一步收敛更准确；收敛速度快缺点：当规模变大时，H矩阵的计算比较难 高斯牛顿法 原先是对其损失函数即残差函数的一个二范数求最小值，而高斯牛顿法是直接对残差函数进行泰勒展开，同时保留其一阶导求雅可比矩阵：问题变为寻找增量$\\Delta x$使得$| f(x+\\Delta x)|^2$达到最小： \\Delta x^* = arg\\underset {\\Delta x}{min} \\frac 12 \\| f(x + J\\Delta x)\\|^2同样地，需要对其求导且导数为0的情况下为最小，展开为： \\begin{equation} \\begin{split} \\frac 12 \\| f(x + J\\Delta x)\\|^2 &= \\frac 12(f(x) + J\\Delta x)^T(f(x) + J\\Delta x) \\\\ &= \\frac 12( \\| f(x) \\|_2^2 + 2f(x)J\\Delta x + \\Delta x^T J^T J \\Delta x ) \\end{split} \\end{equation}对其求导并令其为0，则得到 \\underbrace{J^T f(x)}_{g} + \\underbrace{J^T J}_{H} \\Delta x = 0 \\\\ 即 \\Delta x = H^{-1}g优点: 用$J^TJ$代替牛顿法中的H，则不需要二阶导数缺点：但是求解必须保证H矩阵是可逆的，而$J^TJ$只能保证半正定，算法稳定性变差，最终难以收敛。 在SLAM中的凸优化 基于凸优化的ICP问题，我们将原来的目标函数重新说明一下： minE(R,t)=min\\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|x_i - Ry_i - t\\|^2使用矩阵T对R和t进行表示： T = \\quad \\begin{bmatrix} R & t \\\\ 0 & 1 \\end{bmatrix}目标函数变为: \\underset{T}{min} \\frac 12 \\sum_{i=1}^{N_y} \\|x_i - Ty_i\\|_2^2还有相对应的李代数变换，目前还不会先不记录了。接下来我们对实现代码进行讲解: "},{"title":"Cmd Markdown 公式指导手册","date":"2022-10-24T06:14:21.731Z","url":"/2022/10/24/tools/mathjax_tutorial_mdeditor_220713/","tags":[["Markdown","/tags/Markdown/"]],"categories":[["undefined",""]],"content":" 本文为 MathJax 在 Cmd Markdown 环境下的常用语法指引。Cmd Markdown 编辑阅读器支持 $\\LaTeX$ 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$，访问 MathJax 以参考更多使用方法。 右键点击每一个公式，选择 [Show Math As] → [TeX Commands] 以查看该公式的命令详情。 [TOC] 一、公式使用参考1．如何插入公式$\\TeX$ 可使用行中公式放在文中与其它文字混编，或单独成行的独立公式。 行中公式可以用如下方法表示： : $ 表达式 $ 独立公式可以用如下方法表示： : 表达式 自动编号的公式可以用如下方法表示：: 若需要手动编号，可在公式后使用 \\tag&#123;编号&#125; 语句。 : \\begin{equation} 表达式 \\label{eq:当前公式名}\\end{equation} : 自动编号后的公式可在全文任意处使用 \\eqref&#123;eq:公式名&#125; 语句引用。 例子： 显示： $ J\\alpha(x) = \\sum{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，行内公式示例} $ 例子： 显示： J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text{，独立公式示例，使用 \\tag 手动编号} \\tag{0.1} 例子： 显示： 在公式 \\eqref{eq:sample} 中，我们看到了这个被自动编号的公式。\\begin{equation} E=mc^2 \\text{，自动编号公式示例} \\label{eq:sample}\\end{equation} 不自动编号的公式可以用如下方法表示： : \\begin{equation} 表达式\\end{equation} 2．如何输入上下标^ 表示上标，_ 表示下标。如果上下标的内容多于一个字符，需要用 &#123;&#125; 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。 例子： 显示：x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} 如果要在左右两边都有上下标，可以使用 \\sideset 命令；也可以简单地在符号前面多打一个上下标，此时会以行内公式渲染。本例内 \\quad 均为空格符号，为方便公式格式对比而添加，请注意辨别。详见在字符间加入空格。 例子： 显示：\\sideset{^1_2}{^3_4}\\bigotimes \\quad or \\quad {^1_2}\\bigotimes {^3_4} 3．如何输入括号和分隔符()、[] 和 | 表示符号本身，使用 \\&#123;\\&#125; 来表示 &#123;&#125; 。当要显示大号的括号或分隔符时，要用 \\left 和 \\right 命令。 一些特殊的括号：|输入|显示|输入|显示||—:|:—|—:|:—||\\langle|$\\langle$|\\rangle|$\\rangle$||\\lceil|$\\lceil$|\\rceil|$\\rceil$||\\lfloor|$\\lfloor$|\\rfloor|$\\rfloor$||\\lbrace|$\\lbrace$|\\rbrace|$\\rbrace$||\\lvert|$\\lvert$|\\rvert|$\\rvert$||\\lVert|$\\lVert$|\\rVert|$\\rVert$| @lymd 有时，我们需要在行内使用两个竖杠表示向量间的某种空间距离，可以这样写 \\lVert \\boldsymbol&#123;X&#125;_i - \\boldsymbol&#123;S&#125;_j \\rVert^2 → $\\lVert \\boldsymbol{X}_i - \\boldsymbol{S}_j \\rVert^2$ 例子： 显示：f(x,y,z) = 3y^2z \\left( 3+\\frac{7x+5}{1+y^2} \\right) 4．如何输入分数通常使用 \\frac &#123;分子&#125; &#123;分母&#125; 来生成一个分数，分数可多层嵌套。若分数只有一层，也可使用 分子 \\over 分母 命令。例内 \\quad \\mid \\, 等均为空格或分隔符号，为方便公式格式对比而添加，请注意辨别。详见在字符间加入空格。 例子： 显示：\\frac{a-1}{b-1} \\quad or \\quad {a+1 \\over b+1} 当分式 仅有两个字符时 可直接输入 \\frac ab 来快速生成一个 $\\Large\\frac ab$ 。 例子： 显示：\\frac 12,\\frac 1a,\\frac a2 \\quad \\mid \\quad \\text{2 letters only:} \\quad \\frac 12a \\,, k\\frac q{r^2} 5．如何输入开方使用 \\sqrt [根指数，省略时为2] &#123;被开方数&#125; 命令输入开方。本例内 \\quad 均为空格符号，为方便公式格式对比而添加，请注意辨别。详见在字符间加入空格。 例子： 显示：\\sqrt{2} \\quad or \\quad \\sqrt[n]{3} 6．如何输入省略号数学公式中常见的省略号有两种，\\ldots 表示与 文本底线 对齐的省略号，\\cdots 表示与 文本中线 对齐的省略号。 例子： 显示：f(x_1,x_2,\\underbrace{\\ldots}_{\\rm ldots} ,x_n) = x_1^2 + x_2^2 + \\underbrace{\\cdots}_{\\rm cdots} + x_n^2 7．如何输入向量使用 \\vec&#123;向量&#125; 来自动产生一个向量。也可以使用 \\overrightarrow 等命令自定义字母上方的符号。例内 \\quad \\mid \\, 等均为空格或分隔符号，为方便公式格式对比而添加，请注意辨别。详见在字符间加入空格。 例子： 显示：\\vec{a} \\cdot \\vec{b}=0 例子： 显示：xy \\text{ with arrows:} \\quad \\overleftarrow{xy} \\; \\mid \\; \\overleftrightarrow{xy} \\; \\mid \\; \\overrightarrow{xy} 8．如何输入积分使用 \\int_积分下限^积分上限 &#123;被积表达式&#125; 来输入一个积分。 例子：显示：\\int_0^1 {x^2} \\,{\\rm d}x 本例中 \\, 和 &#123;\\rm d&#125; 部分可省略，但加入能使式子更美观，详见在字符间加入空格及如何进行字体转换。 9．如何输入极限运算使用 \\lim_&#123;变量 \\to 表达式&#125; 表达式 来输入一个极限。如有需求，可以更改 \\to 符号至任意符号。 例子：显示：\\lim_{n \\to \\infty} \\frac{1}{n(n+1)} \\quad and \\quad \\lim_{x\\leftarrow{示例}} \\frac{1}{n(n+1)} 10．如何输入累加、累乘运算使用 \\sum_&#123;下标表达式&#125;^&#123;上标表达式&#125; &#123;累加表达式&#125; 来输入一个累加。与之类似，使用 \\prod \\bigcup \\bigcap 来分别输入累乘、并集和交集，更多符号可参考“其它特殊字符”。 此类符号在行内显示时上下标表达式将会移至右上角和右下角，如 \\sum_&#123;i=1&#125;^n \\frac&#123;1&#125;&#123;i^2&#125; 显示为 $\\sum_{i=1}^n \\frac{1}{i^2}$ ； 或： @woria 在行内可使用 \\sum\\limits_&#123;下标表达式&#125;^&#123;上标表达式&#125; &#123;累加表达式&#125; 使上下标仍在正上正下方。 如 \\sum\\limits_&#123;i=1&#125;^n \\frac&#123;1&#125;&#123;i^2&#125; 显示为 $\\sum\\limits_{i=1}^n \\frac{1}{i^2}$ 。 本例内 \\quad 均为空格符号，为方便公式格式对比而添加，请注意辨别。详见在字符间加入空格。 例子： 显示：\\sum_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\prod_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\bigcup_{i=1}^{2} \\Bbb{R} 11．如何输入希腊字母输入 \\小写希腊字母英文全称 和 \\首字母大写希腊字母英文全称 来分别输入小写和大写希腊字母。对于大写希腊字母与现有字母相同的，直接输入大写字母即可。 输入 显示 输入 显示 输入 显示 输入 显示 \\alpha $\\alpha$ A $A$ \\beta $\\beta$ B $B$ \\gamma $\\gamma$ \\Gamma $\\Gamma$ \\delta $\\delta$ \\Delta $\\Delta$ \\epsilon $\\epsilon$ E $E$ \\zeta $\\zeta$ Z $Z$ \\eta $\\eta$ H $H$ \\theta $\\theta$ \\Theta $\\Theta$ \\iota $\\iota$ I $I$ \\kappa $\\kappa$ K $K$ \\lambda $\\lambda$ \\Lambda $\\Lambda$ \\mu $\\mu$ M $M$ \\nu $\\nu$ N $N$ \\xi $\\xi$ \\Xi $\\Xi$ o $o$ O $O$ \\pi $\\pi$ \\Pi $\\Pi$ \\rho $\\rho$ P $P$ \\sigma $\\sigma$ \\Sigma $\\Sigma$ \\tau $\\tau$ T $T$ \\upsilon $\\upsilon$ \\Upsilon $\\Upsilon$ \\phi $\\phi$ \\Phi $\\Phi$ \\chi $\\chi$ X $X$ \\psi $\\psi$ \\Psi $\\Psi$ \\omega $\\omega$ \\Omega $\\Omega$ 部分字母有变量专用形式，以 \\var- 开头。 小写形式 大写形式 变量形式 显示 \\epsilon E \\varepsilon $\\epsilon \\mid E \\mid \\varepsilon$ \\theta \\Theta \\vartheta $\\theta \\mid \\Theta \\mid \\vartheta$ \\rho P \\varrho $\\rho \\mid P \\mid \\varrho$ \\sigma \\Sigma \\varsigma $\\sigma \\mid \\Sigma \\mid \\varsigma$ \\phi \\Phi \\varphi $\\phi \\mid \\Phi \\mid \\varphi$ 12．如何输入其它特殊字符 完整的 $\\LaTeX$ 可用符号列表可以在 这份文档 中查阅（极长，共 348 页），大部分常用符号可以参阅 这份精简版文档 查询。需要注意的是，$\\LaTeX$ 符号并不保证在 MathJax v2.2 中可用，即在 Cmd Markdown 编辑阅读器中可能并不支持所输入的特定命令。 若需要显示更大或更小的字符，在符号前插入 \\large 或 \\small 命令。MathJax 针对任意元素均提供从小至大 \\tiny \\Tiny \\scriptsize \\small *默认值 \\normalsize \\large \\Large \\LARGE \\huge \\Huge 共十种渲染大小，详见官方文档。 若找不到需要的符号，推荐使用 $\\large\\rm{Detexify}$ 来画出想要的符号 (1)．关系运算符 输入 显示 输入 显示 输入 显示 输入 显示 \\pm $\\pm$ \\times $\\times$ \\div $\\div$ \\mid $\\mid$ \\nmid $\\nmid$ \\cdot $\\cdot$ \\circ $\\circ$ \\ast $\\ast$ \\odot $\\odot$ \\otimes $\\otimes$ \\oplus $\\oplus$ \\leq $\\leq$ \\geq $\\geq$ \\neq $\\neq$ \\approx $\\approx$ \\equiv $\\equiv$ \\sum $\\sum$ \\prod $\\prod$ \\coprod $\\coprod$ \\backslash $\\backslash$ (2)．集合运算符 输入 显示 输入 显示 输入 显示 \\emptyset $\\emptyset$ \\in $\\in$ \\notin $\\notin$ \\subset $\\subset$ \\supset $\\supset$ \\subseteq $\\subseteq$ \\supseteq $\\supseteq$ \\cap $\\cap$ \\cup $\\cup$ \\vee $\\vee$ \\wedge $\\wedge$ \\uplus $\\uplus$ \\top $\\top$ \\bot $\\bot$ \\complement $\\complement$ (3)．对数运算符 输入 显示 输入 显示 输入 显示 \\log $\\log$ \\lg $\\lg$ \\ln $\\ln$ (4)．三角运算符 输入 显示 输入 显示 输入 显示 \\backsim $\\backsim$ \\cong $\\cong$ \\angle A $\\angle A$ \\sin $\\sin$ \\cos $\\cos$ \\tan $\\tan$ \\csc $\\csc$ \\sec $\\sec$ \\cot $\\cot$ (5)．微积分运算符 输入 显示 输入 显示 输入 显示 \\int $\\int$ \\iint $\\iint$ \\iiint $\\iiint$ \\partial $\\partial$ \\oint $\\oint$ \\prime $\\prime$ \\lim $\\lim$ \\infty $\\infty$ \\nabla $\\nabla$ (6)．逻辑运算符 输入 显示 输入 显示 输入 显示 \\because $\\because$ \\therefore $\\therefore$ \\neg $\\neg$ \\forall $\\forall$ \\exists $\\exists$ \\not\\subset $\\not\\subset$ \\not&lt; $\\not&lt;$ \\not&gt; $\\not&gt;$ \\not= $\\not=$ @xiaobanni \\vdash 显示为 $\\vdash$ (7)．戴帽符号 输入 显示 输入 显示 输入 显示 \\hat{xy} $\\hat{xy}$ \\widehat{xyz} $\\widehat{xyz}$ \\bar{y} $\\bar{y}$ \\tilde{xy} $\\tilde{xy}$ \\widetilde{xyz} $\\widetilde{xyz}$ \\acute{y} $\\acute{y}$ \\breve{y} $\\breve{y}$ \\check{y} $\\check{y}$ \\grave{y} $\\grave{y}$ \\dot{x} $\\dot{x}$ \\ddot{x} $\\ddot{x}$ \\dddot{x} $\\dddot{x}$ 若需要在特定文字顶部\\底部放置内容，可使用 \\overset&#123;顶部内容&#125;&#123;正常内容&#125; 和 \\underset&#123;底部内容&#125;&#123;正常内容&#125; 命令。例内 \\qquad \\quad \\mid \\; \\, 等均为空格或分隔符号，为方便公式格式对比而添加，请注意辨别。详见在字符间加入空格。 例子： 显示： \\verb+\\overset{above}{level}+ \\qquad \\overset{xx}{ABC} \\;\\; \\mid \\quad \\overset{x^2}{\\longmapsto}\\ \\, \\mid \\quad \\overset{\\bullet\\circ\\circ\\bullet}{T} 例子： 显示：\\verb+\\underset{below}{level}+ \\qquad \\underset{xx}{ABC} \\;\\; \\mid \\quad \\underset{x^2}{\\longmapsto}\\ \\, \\mid \\quad \\underset{\\bullet\\circ\\circ\\bullet}{T} 此命令可叠加嵌套使用，生成类似化学反应式的多重条件符号，如 \\overset&#123;H_2&#125;&#123;\\underset&#123;1300℃&#125;&#123;\\Longleftrightarrow&#125;&#125;： \\rm{SrO+V^{''}_{Sr} \\overset{H_2}{\\underset{1300℃}{\\Longleftrightarrow}} Sr^{\\times}_{Sr}+2e^{'}+\\frac 12O_2(g)} $$ 和 `\\overset{Surface/bulk}{\\underset{diffusion}{\\longleftrightarrow}}`： $$ \\rm{2OH^{\\circ}_{O(STN)}+2O^{\\times}_{O(YSZ)} \\; \\overset{Surface/bulk}{\\underset{diffusion}{\\longleftrightarrow}} \\;\\; 2OH^{\\circ}_{O(YSZ)}+2O^{\\times}_{O(STN)}}在书写化学方程式时可声明 \\require&#123;AMDcd&#125; 语句，使用 MathJax 内置的交换图表功能，具体例子可参见下文。 (8)．连线符号其它可用的文字修饰符可参见官方文档 “Additional decorations”。 输入 显示 \\fbox{a+b+c+d} 高级框选需声明 enclose 标签 $\\fbox{a+b+c+d}$ \\overleftarrow{a+b+c+d} $\\overleftarrow{a+b+c+d}$ \\overrightarrow{a+b+c+d} $\\overrightarrow{a+b+c+d}$ \\overleftrightarrow{a+b+c+d} $\\overleftrightarrow{a+b+c+d}$ \\underleftarrow{a+b+c+d} $\\underleftarrow{a+b+c+d}$ \\underrightarrow{a+b+c+d} $\\underrightarrow{a+b+c+d}$ \\underleftrightarrow{a+b+c+d} $\\underleftrightarrow{a+b+c+d}$ \\overline{a+b+c+d} $\\overline{a+b+c+d}$ \\underline{a+b+c+d} $\\underline{a+b+c+d}$ \\overbrace{a+b+c+d}^{Sample} $\\overbrace{a+b+c+d}^{Sample}$ \\underbrace{a+b+c+d}_{Sample} $\\underbrace{a+b+c+d}_{Sample}$ \\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0} $\\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0}$ \\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}} $\\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}}$ (9)．箭头符号 推荐使用符号：|输入|显示|输入|显示|输入|显示||:—:|:—:|:—:|:—:|:—:|:—:||\\to|$\\to$|\\mapsto|$\\mapsto$|\\underrightarrow{1℃/min} | $\\underrightarrow{1℃/min}$ ||\\implies|$\\implies$|\\iff|$\\iff$|\\impliedby|$\\impliedby$| 其它可用符号：|输入|显示|输入|显示||:—:|:—:|:—:|:—:||\\uparrow|$\\uparrow$|\\Uparrow|$\\Uparrow$||\\downarrow|$\\downarrow$|\\Downarrow|$\\Downarrow$||\\leftarrow|$\\leftarrow$|\\Leftarrow|$\\Leftarrow$||\\rightarrow|$\\rightarrow$|\\Rightarrow|$\\Rightarrow$||\\leftrightarrow|$\\leftrightarrow$|\\Leftrightarrow|$\\Leftrightarrow$||\\longleftarrow|$\\longleftarrow$|\\Longleftarrow|$\\Longleftarrow$||\\longrightarrow|$\\longrightarrow$|\\Longrightarrow|$\\Longrightarrow$||\\longleftrightarrow|$\\longleftrightarrow$|\\Longleftrightarrow|$\\Longleftrightarrow$| 13．如何进行字体转换若要对公式的某一部分字符进行字体转换，可以用 &#123;\\字体 &#123;需转换的部分字符&#125;&#125; 命令，其中 \\字体 部分可以参照下表选择合适的字体。一般情况下，公式默认为斜体字 $italic$ 。 示例中 全部大写 的字体仅大写可用。 输入 全字母可用 显示 输入 仅大写可用 显示 \\rm 罗马体 $\\rm{Sample}$ \\mathcal 花体（数学符号等） $\\mathcal{SAMPLE}$ \\it 斜体 $\\it{Sample}$ \\mathbb 黑板粗体（定义域等） $\\mathbb{SAMPLE}$ \\bf 粗体 $\\bf{Sample}$ \\mit 数学斜体 $\\mit{SAMPLE}$ \\sf 等线体 $\\sf{Sample}$ \\scr 手写体 $\\scr{SAMPLE}$ \\tt 打字机体 $\\tt{Sample}$ \\cal 等同于 \\mathcal $\\cal{ABCXYZ}$ \\frak 旧德式字体 $\\frak{Sample}$ \\Bbb 等同于 \\mathbb $\\Bbb{ABCXYZ}$ @lymd \\boldsymbol&#123;\\alpha&#125; 用来表示向量或者矩阵的加粗斜体，如向量 $\\boldsymbol{\\vec\\alpha}$ 。 转换字体十分常用，例如在积分中： 例子： 显示：\\begin{array}{cc} \\mathrm{Bad} &amp; \\mathrm{Better} \\ \\hline \\ \\int_0^1 x^2 dx &amp; \\int_0^1 x^2 \\,{\\rm d}x\\end{array} 注意比较两个式子间 $dx$ 与 ${\\rm d} x$ 的不同。使用 \\operatorname 命令也可以达到相同的效果，详见定义新的运算符。 14．如何高亮一行公式使用 \\bbox[底色, (可选)边距, (可选)边框 border: 框宽度 框类型 框颜色] 命令来高亮一行公式。底色和框颜色支持详见“更改文字颜色”，边距及框宽度支持 绝对像素 px 或 相对大小 em，框类型支持 实线 solid 或 虚线 dashed。 例子： 显示： \\bbox[yellow]{ e^x=\\lim_{n\\to\\infty} \\left( 1+\\frac{x}{n} \\right)^n \\qquad (1) } 例子： 显示： \\bbox[#9ff, 5px]{ e^x=\\lim_{n\\to\\infty} \\left( 1+\\frac{x}{n} \\right)^n \\qquad (1) } 例子： 显示：$$\\bbox[#2f3542, 0.5em, border:2px solid #f1f2f6]{ \\color "},{"title":"激光SLAM学习 前端里程计","date":"2022-10-21T14:15:05.037Z","url":"/2022/10/21/SLAM/Odemeter/","tags":[["AI","/tags/AI/"],["Deep learning","/tags/Deep-learning/"],["SLAM","/tags/SLAM/"]],"categories":[["undefined",""]],"content":"简介 在课程中的介绍，前端里程计的作用是为了将当前点云与已存在点云进行相对位姿的计算，在当前点云: 在当前时刻帧，激光雷达对周围环境采集的点云已存在点云 ：上一帧或已建成地图的点云课程中介绍了多种前端里程计基本算法，分别为以下： 基于直接匹配的方法：整体点云直接匹配，包括ICP（Iterative Closest Point），NDT（Normal Distribution Transformation）等 基于特征：LOAM, A-LOAM, F-LOAM, LEGO-LOAM 多传感器融合里程计： LINS, LIO-SAM, LIO-mapping 基于栅格： cartographer 基于面元： suma 基于语义： segmap, suma++ 其中课程中主要对前三个进行讲解和分析，并给出实现代码和运行框架。 在其他文章中，对其前端里程计基本算法进行学习和笔记记录，包括公式推导和代码讲解。"},{"title":"激光SLAM学习 深蓝学院课程 简介","date":"2022-10-21T13:04:11.857Z","url":"/2022/10/21/SLAM/Introduction/","tags":[["AI","/tags/AI/"],["Deep learning","/tags/Deep-learning/"],["SLAM","/tags/SLAM/"]],"categories":[["undefined",""]],"content":"简介这是有关激光雷达SLAM的学习，其核心是利用激光雷达传感器以及内置的其他传感器，对周围环境进行构建地图并定位激光雷达所在坐标，即同步定位和建图（Simultaneous Localization and Mapping，SLAM），其流程框架如下图。 整体分为三个部分： • 前端匹配：通过观测点云与目标点云进行匹配得到相对位姿 目标点云：建图时为首帧，定位时为已有地图 • 匹配关键帧：在所有前端匹配帧中，选取最优的作为关键帧 • 后端优化：利用其他传感器进行约束和计算，优化生成地图 前端里程计在课程中的介绍，前端里程计的作用是为了将当前点云与已存在点云进行相对位姿的计算，在当前点云: 在当前时刻帧，激光雷达对周围环境采集的点云已存在点云 ：上一帧或已建成地图的点云课程中介绍了多种前端里程计基本算法，分别为以下： 基于直接匹配的方法：整体点云直接匹配，包括ICP（Iterative Closest Point），NDT（Normal Distribution Transformation）等 基于特征：LOAM, A-LOAM, F-LOAM, LEGO-LOAM 多传感器融合里程计： LINS, LIO-SAM, LIO-mapping 基于栅格： cartographer 基于面元： suma 基于语义： segmap, suma++ 其中课程中主要对前三个进行讲解和分析，并给出实现代码和运行框架。 在其他文章中，对其前端里程计基本算法进行学习和笔记记录，包括公式推导和代码讲解。"},{"title":"深度学习笔记","date":"2022-10-19T13:45:39.211Z","url":"/2022/10/19/DeepLearningByAndrewNg/","tags":[["AI","/tags/AI/"],["Deep learning","/tags/Deep-learning/"]],"categories":[["undefined",""]],"content":"Stanford CS230(吴恩达 深度学习 Deep Learning | Autumn 2018)笔记第零课深度学习是什么？深度学习一般与神经网络是一个同义词，Deep Learning简称DL，与传统的Machine Learning(ML)不同，但是是ML的一部分，也是最难的一部分。 深度学习兴起主要是由于互联网发展以及GPU计算的能力提升，更多数据被电子化以及计算力的大幅提升，使得神经网络变得更大更能解决更多数据带来的问题和潜在的有价值的东西。 一个好的AI团队需要什么？ 团队一般具备各种数据采集能力 团队能通过深度学习来对数据进行分析 普遍的自动化 本课程含五个Courses： 什么是神经元？什么是神经网络层？如何将他们堆叠起来搭建神经网络？ 如何调整(tune)这些神经网络？如何改进神经网络的效果？ 机器学习项目的开发流程 卷积神经网络(CNN Convolutional Neural Network) 序列模型(Sequence Model)如递归神经网络(Recurrent Neural Network) 参考课程视频：对于2中的每一个视频，先到1中看了视频在看2，效果会好一些 2中视频备注如C1M1，代表第一个Courses(一共上面5个),每个有很多modules，一般一个视频两个modules Courses In-class 第一课神经网络的有监督学习建立y(y1,y2…)到x(x1,x2,x3,x4…)的映射关系，我们给出数据包含(x,y)对神经网络进行训练，找到最佳的参数来表达y和x之间的关系。 有监督学习的x输入结构化数据：表格类型的，矩阵类型的数据非结构化数据：声音，图像，文本等 神经网络基础神经网络包含前向过程(forward propagation) 和 反向传播过程(backward propagation)即BP 简单的二元逻辑回归例子 问题模型描述：输入x∈Rnx，是输出y则是label∈{0,1},一共有m个训练样本{(x1,y1),(x2,y2)…(xm,ym)} 对于训练样本的m个输入x，进行堆叠为一个nx × m的矩阵，y同样为1 x m的矩阵 在这里我们使用$\\hat{y}$表示通过算法预测的结果，我们需要它与y形成一个概率的关系，即取值为{0~1},由于直接使用线性函数去拟合，我们输出只有0~1的情况下，有可能会输出负数,或者超过1，这里我们使用一个叫sigmoid函数对线性拟合处理，sigmoid表示为如下 $\\frac{1}{1+e^{-z}}$, 原来y = wTx + b表示为y = $\\delta$ (wTx + b) 梯度下降上述损失函数很好地描述了w和b对Y和$\\hat{y}$之间的的关系，但是我们要得到更好地使得J(w,b)更小，在这里我们提出梯度下降法来求解w和b使得J(w,b)最小。 神经网络的理解 如上图，神经网络可以理解为是一个黑箱，函数，输入图像，经过结构和参数得到里面是否有猫，有=1，无=0，这是一个基本的神经网络的模式。 神经网络模型 = 结构 + 参数 我们的目标就是要找到在结构中最佳的参数来的到最好的结果，我们可以改变这个模式中的很多东西： 输入input，将图片换成其他的数据格式 输出output，改变求解问题，如要求猫的种类(多类分类)，猫的年龄(线性回归) 损失函数Loss function，根据与真值的比较定义的误差来更新 结构Architecture，一般以结构来命名神经网络如循环神经网络，卷积神经网络等 激活函数Activation function， 优化器Optiomizer, 超参数Hyperparameters，如学习率,优先的批处理等外部设置的参数 其中几个例子一、分类问题问题描述：给一张图片，要分辨出是猫或不是猫（白天或黑夜）问题分析： 输入：表示为像素矩阵的图片(二维矩阵) 输出：类型（猫或非猫） 损失函数：二元逻辑回归，目标是猫（0），不是猫是(1)，设置阈值如(0.5) 结构：有很多如CNN,RCNN等 激活函数：使用sigmoid函数，使得输出保持在0~1之间 如果是多分类问题（分类几种动物）有以下几个解决方法： 单热编码，这样能在一张图片上同时出现两种动物，但这样需要使用softmax激活函数。 训练多神经网络，每一个对应一种动物，这样效率不高不能有效利用。 训练时，需要输入多张带标签的动物图片，在训练时进行带标签（编码）的训练 二、人像识别问题描述：输入人脸后，需要知道是不是对应学生（id）的问题分析： 输入: 表示为像素矩阵的图片(二维矩阵) 输出：判断是否为指定的学生，二分类，设置阈值 损失函数：输入的待认证图像与图像库中的图像进行匹配，向量化的差值基本与上面相同，但比较先进的人脸识别方法应该不是这样的，有一定的改进但总体思路是一样的。 三、风格转移问题描述：给出一张图片的内容和另一张图片的风格，生成1图片内容含2图片风格问题分析： 数据：目标content和目标style图 输入：随机白噪声或带偏置的图（或其他的） 输出：含有content和style的图 损失函数：生成的图片同时与content之间的内容差值和style图之间的style差值 四、语音识别问题描述：给出一段语音，识别出其中的激活词问题分析： 数据：很多包含或不包含（正负样本）激活词的样本集，有两种方式： ①：找很多人录音，手动标记； ②：收集正样本和负样本插入到背景噪音中，可以程序化生成样本并自动标记 输入：一段待识别的语音 输出：对每个时序输出0或1来识别激活词 损失函数：编码后的语音与激活词之间的距离 结构：RNN，LSTM结构 虽然以上方法很好地定义了其中很多内容，但关键影响效果的是结构和它的参数调整能否有效"},{"title":"有关一些文件处理","date":"2022-10-19T13:45:39.158Z","url":"/2022/10/19/tools/DataFile%20Dealing/","categories":[["undefined",""]],"content":"Introduction由于利用mahjong-helper处理麻将牌谱,整理一下几种人工智能数据格式在python中的处理方式。 xls和xlsxpython中对于这两种文件有三个库可以用，xlwt，xlrd和openpyxl，这里以xlrd为例，其他两个大同小异。 excel文档有三个概念，workbook(文档)，sheet(表单)，cell(单元格)，以下是一个demo遍历每一个单元格： csvcsv跟上面的不一样，它默认有表头，并且只能存一张表，用的是pandas的read_csv函数来读的，返回的是pandas的DataFrame对象。 hdf5这个是最复杂的文件结构，它用的是类Unix的文件组织结构来组织文件。在python中用的是h5py的库"},{"title":"Mahjong AI","date":"2022-10-19T13:45:38.565Z","url":"/2022/10/19/mahjong%20AI/","tags":[["AI","/tags/AI/"],["日麻","/tags/%E6%97%A5%E9%BA%BB/"]],"categories":[["undefined",""]],"content":"简介这是一个关于日本麻将人工智能算法的笔记，期望以后能进行推进开发实用。 相关文献 NaoKi Mizukami 水上直紀 多人数性を分割した教師付き学習による四人麻雀プログラムの実現原版 中文版 NaoKi Mizukami 水上直紀 Building a Computer Mahjong Player Based on Monte Carlo Simulation and Opponent Models原版 中文版 NaoKi Mizukami 水上直紀 期待最終順位に基づくコンピュータ麻雀プレイヤの構築原版 Ryouhei KITAGAWA 北川竜平 麻雀の牌譜からの打ち手評価関数の学習原版 NaoKi Mizukami 水上直紀 牌譜を用いた対戦相手のモデル化とモンテカルロ法によるコンピュータ麻雀プレイヤの構築 NaoKi Mizukami 水上直紀 強化学習を用いた効率的な和了を行う麻雀プレイヤ NaoKi Mizukami 水上直紀 多人数不完全情報ゲームにおける仮想自己対戦を用いた強化学習 NaoKi Mizukami 水上直紀 降りるべき局面の認識による1 人麻雀プレイヤの4 人麻雀への適用 感谢译者 零之审判(北京大学数学科学学院 学士毕业) 译者注 译者关于这几篇论文的看法以及理解，很值得一看 感谢本博客基于的是mahjong-helper的代码。该平台支持天凤和雀魂，查看和分析牌谱，实时获取当前数据，并进行分析，同时跨平台支持linux，windows和mac。~日麻杂谈群375865038~ 我在其中添加该算法，使用的是该平台的雀魂平台上进行试验。 日本麻将术语暂时不写了，是日麻基本规则 基于有监督的单人麻将程序 这部分讲述三篇水上直紀大佬写的三篇文章中，关于单人麻将的算法以及它们的基本原理，本人理解有限，希望能复现他们的工作(希望能改进)。 单人麻将的规则所以基本就是一直摸切摸切，有点像第一代雀魂的AI，不会鸣牌(因为单人麻将不能鸣牌)，一直摸直到流局或立直。 基于平均感知器的算法这是第一篇文章中的单人麻将的算法，利用的是基于平均感知器的算法来减少向听达成自摸。平均感知器是基于条件随机场的的全局化以最大熵准则建模的函数的一个有监督模型。[1] 算法流程文章中使用的特征量提取模型，是用的2007年北川论文中的特征量。引用译者的翻译: 特征类 特征个数 面子手、七对子、国士无双向听数 15+7+14=36 3色（万、筒、索）中不使用n色（n=1˜ 3）的n和向听数 3×16=48 色的个数（1˜ 4）及各色向听数的组合 12+78+364+1365=1819 各色牌中最多的数量 15 各色牌中最多的数量+字牌数 15 2到8的数牌量 15 面子和不含有幺九的连续2张牌的搭子和面子候补的组合 6+12+72=90 各字牌的枚数和役牌的枚数和是否是宝牌的组合 5×6×2=60 数牌的数字-5的绝对值和枚数和是否是宝牌的组合 5×5×2=50 各色牌中是否有1˜ 9的组合 512 连续的n个数牌中各牌数量的组合（n=2˜ 6） 100+500+1860+8634+23760=34854 我们来分析一下某几个特征量是怎么算出来的，例如第一行中的国士无双向听数，最简单的就是0向听˜13向听，那就是一共14种情况，即特征个数。七对子也是0˜7向听等。 对于所有牌谱中的手牌(局面),当轮到主视角时，手牌有14张，我们来计算切掉每一张牌后，剩下的13张牌所组成的特征量的得分。 $f(x,w)=\\sum_{i=1}^{n}x_iw_i$ 一共有14张牌得分，计算出得分最高的切牌$\\widehat{t}$的得分以及实际切牌$t*$的得分，如果不相同则以实际切牌的为准，并更新权重，根据两个切牌的特征向量，原权重加上实际切牌的权重再减去最高得分切牌权重，更新公式如下 $w^{‘}=w+x{t*}-x\\widehat{t}$ 遍历三遍输入训练数据后，输出权重，根据得分最高的来打牌。 有监督训练集由于使用的是牌谱的有监督学习，且是单人麻将，文章中采用的牌谱是天凤凤凰桌所有局中，第一个立直的人直到立直的所有切牌数据作为训练数据，一共有170万个局面(手牌状况)。但是作者并没有公开这些数据，复现这个方法需要大量的牌谱，而且是顶尖选手的牌谱。 攻防判断——识别是否弃和该部分是识别当前的局面是否应该弃和，在这篇文章中，采用的是二分类法，用了SVM的分类器根据局面上提取的特征来判断是否弃和。同时，如果一个局面被标记为弃和后，之后的所有局面都应标记为弃和。而兜牌是不被标记为弃和的，只是进攻的一个手段。 同时文章提及是否弃和是一个比较主观的定义，是有一些局面的判断是非常难判断的。但考虑到人类玩家弃和的思考方式，采用安全度来判断是否弃和： 标记好数据后，使用SVM分类器，判断是否弃和的特征向量如下，共7+3*8+3=34维。 特征类 数量 自身状态 向听数 1 七对子向听数 1 是否立直 1 是否坐庄 1 副露数 1 副露的宝牌数 1 手牌宝牌数 1 对手状态 是否立直 1 副露数 1 副露可见的宝牌数 1 是否坐庄 1 想切的牌对该玩家安全度 4 场上状况 牌山剩余量 1 杠的数量 1 牌河里宝牌数量 1 加入程序鸣牌的能力鸣牌程序训练跟第一部分单人程序大致相同，使用鸣牌局面的牌谱来进行训练，同样使用平均感知器算法来对局面的所有特征向量来分类，下表是跟单人麻将差不多的特征向量： 特征类 特征个数 副露数 5 是否可能立直 2 各色的1˜9数牌数量变换到0，1，2以上的牌型 19472 副露里选择n（1˜2）个副露的种类组合 136+9316=9452 手牌里有3张以上相同牌的数量和2张以上相同牌的数量的组合 5×7=35 手牌里有3张以上相同牌的数量+碰的个数和2张以上相同牌的数量的组合，还有是否吃牌 5×7+1=36 手牌和副露中断幺牌数量和向听数 16+16=32 连续的各色的3张数牌里的有无和3张里是否包含幺九和是否包含吃的组合 512×2×2=2048 包含吃的各色里幺九的有无 512 各色牌中最多的数量+该色和字牌的副露数×3 16 各色牌中最多的数量+字牌个数+该色和字牌的副露数×3 16 做特定色染手的向听数 16 役牌对子数 8 役牌刻子数 6 宝牌个数（0，1，2，3以上）和2˜8数牌中宝牌数量 4+4=8 副露数和向听数的组合 5×15=75 向听数和有役、有门清限定役、没役和巡目的组合 2×3×19=114 有役和是否是门清限定役和没有役 3 是否鸣了幺九牌和加入幺九牌时向听数减少的量（0，1，2以上） 2×3=6 手牌里不使用幺九牌的向听数增加的量（0，1，2以上） 3 加上所有副露的风牌后其数量（0，1，2，3以上）的组合 4×4×4×4=256 加上所有副露的三元牌后其数量（0，1，2，3以上）的组合 4×4×4=64 副露数和向听数和加入已经切出的牌是否减少向听数的组合 5×4×2=40 结合单人麻将，攻防判断和鸣牌打法有了不鸣牌，攻防判断以及鸣牌的打法，就可以基本训练出电脑程序打麻将的逻辑所有部分 结合前面三个部分可以完成这个流程，完成打麻将的策略。 总结这个论文的程序基本提供了一种有监督的方法来训练程序对门清状态的打牌，攻防判断和鸣牌的打法学习。但仍有很多不足，在文中认为弃和后，不会再次副露。训练集都是能和牌的局面，那么在手牌难以和牌的时候进行错误鸣牌，文中也说能通过在训练样本中加入没有和牌的局面解决。 References [1]: 平均感知器  [2]: 手牌特征量分析 北川竜平、三輪 誠 、近山 隆. 麻雀の牌譜からの打ち手評価関数の学習. Proceedings of the 12thGame Programming Workshop, 2007"}]