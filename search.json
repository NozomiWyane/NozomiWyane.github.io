[{"title":"N1文法","date":"2022-12-15T08:15:40.192Z","url":"/2022/12/15/nihongo/nihongo/","tags":[["日语学习","/tags/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"],["N1","/tags/N1/"]],"categories":[["undefined",""]],"content":"N1 文法1. ~も同然だ意味：ほとんど～ と同じだ。同じ様子だと言いたい。接続：名詞（も）＋同然だ、ないも同然だ、動詞た形も＋同然だ。 例： (1)：毎日二十時間半年もN1を勉強したんだから、合格したも同然だ。因为半年来每天学习20小时的N1，跟已经合格了已经一样了。个人理解：这里的同然だ就是理所当然的意思，有因果关系导致的结果虽然还没发生，但是在说话人眼里已经发生了，理所当然会发生。 (2)：彼女と三年間一緒に住んでたから、これは結婚生活も同然だ。跟女朋友一起住了三年，这跟结婚生活没有区别了。个人理解：这里的同然だ与同じだ区别不大，重点是前面有一个これは，意思是二者已经相同了，差别不大的意思。 (3)：会社からものを借りて返さないのは、泥棒同然だと思います。借公司的东西不还，我认为跟小偷没有区别。个人理解：这里的同然だ指的是同样有两件事，将“借东西不还”跟小偷作比较，二者相同的意思。 (4)：この医者じゃら手術をもらえば、完治したも同然だ。如果这个医生给我做手术的话，就等于是医治好了。个人理解：同样的，这里也有如果这个因果关系，跟前面的から也是差不多的，有点类似虚拟语气的感觉。 (5)：あなたは家族同然ですよ。你跟家人一样了。个人理解：这里二者需要本质不能是确认关系，本来不是家人的情况下，跟家人一样，前面可以有原因等等支持。 2. とは意味：意外な気持ちを強く表す。残念や驚きを言いたい場合は使える。接続：名詞（も）＋とは、い形容詞＋とは、な形容詞（だ）＋とは動詞普通形＋とは。 例： (1)：あんな静かな由香先生があんなに怒るとは、何があっただろう？这样安静的由香老师居然这么生气，发生了什么呢？个人理解：对“安静的由香老师居然这么生气”具有惊讶的感觉，所以为とは，表示强调自己很惊讶，很意外。普通就是のは，没有这么强调自己的表达感情。 (2)：おとながこどもに負けるとは、情けない！大人输给小孩这件事，太可耻了！个人理解：同样的对“大人输给小孩”表示惊讶，也有遗憾等意外的感情 (3)：あいつが由香先生とデートするとは！这人跟由香老师居然约会了！个人理解：同样的对这人跟由香老师约会了这件事很惊讶,完全没想到。 (4)：あんなに家族と仲良くしてる人に、愛人がいるとは想像もできない。跟家里人关系这么好的人，居然有情妇是想象不出来的。个人理解：同样前面添加了一个条件，后面有情妇是意外的，想象不出来的。 3. ～に越したことはない意味：～のほうがいい、最高だ接続：名詞（である）に、い形容詞、な形容詞（である）、動詞普通形＋に越したことはない。 例：（这个词组很好理解，不解释了，注意这些接的词都是要接个に） (1)：会社は近いに越したことはない。离公司近是最好不过了。 (2)：結婚相手は、子供好きの男性に越したことはない离公司近是最好不过了。 (3)：成功のために、好きなことをやるには越したことはない。要成功的话，做自己喜欢的事情是最好不过了。 (4)：初デートの終わりはキスに越したことはない。初次约会以吻来结束是最好不过了。 4. ａいかん「によって」（で、では）、ｂ ｂはａいかん「だ」（による、にかかっている）意味：ａが、どれぐらいか、どのようなものかによって、Ｂが決まるa怎么样，是什么样的、来决定b是怎么样的，a是条件接続：名詞＋（の）＋いかんによって 例： (1)：N1合格は君のやる気いかんによると思うよ。我觉得N1的合格取决于你的干劲。个人理解：いかんによる前面接的是条件，可以翻译成取决于，虽然N1合格放在了前面，但是这个词组接的就是条件。 (2)：明日の天気いかんいよっては、試合は中止するかもしれない。看明天的天气如何，可能会中止比赛。个人理解：虽然后面这个终止比赛表示b，前面的明天天气是a，可能终止比赛就是一个可能的结果，取决于明天的天气。 (3)：筆記試験いかんで、面接が決まります。笔试怎么样，决定你能否进入面试。个人理解：这个“面试”在这里是b，同样也只是其中一种结果，就是可不可以面试取决于笔试过没过。 5. ａいかん「によらず」（にかかわらず、をとわず）、ｂ意味：ａとは関係なく、Ｂは決まっている不管a怎么样、b都决定了接続：名詞＋の＋いかん「によらず」（にかかわらず、をとわず）。 例：很好理解，注意前面是名词要加の，a是要有两种以上的不确定性 (1)：お支払いになった会員料は理由のいかんによらず、お返しすることができません。已经支付了的会员费不管什么理由，都不能返还。 (2)：結果のいかんによらず、今回の大会に参加できたことに価値を感じております。不管结果如何，我都感受到了参加这次比赛的价值。 (3)：会議の参加、不参加のいかんによらず、明日までは報告集を提出しなきゃいけない。不管参不参加会议，明天之前都必须要提交报告书。 6. ａずにはおかない、 ａないでおかない意味：絶対にａにする、自然に（感情）になる绝对要做a这件事，这件事变成这样是很自然的，很应该的。接続：動詞のない形＋ずにはおかない。 例： (1)：犯罪を見たら、警察に通報せずにはおかないだろう。见到犯罪的话，就应该绝对要报警。个人理解：ない形接おかない就是不做什么是不行的，但是中文翻译的话有点强迫的意思，其实更应该是主动的。 (2)：あの映画俳優が出演したから、この映画は観客を泣かせずにはおかないはずだ。因为那个电影演员出演了（这部戏），这个电影不让看了的人落泪是不可能的。（这个电影让看了的人流泪是必然的） (3)：子供の非行は親の心を傷つけずにおかなかった。孩子做错事让父母伤心是自然的吧。个人理解：这里这样说更像是一些常理性质的事情也可以用这个句型。 (4)：高額の美術品を壊したから、彼に弁償させずにはおかない。破坏了高价值的美术品的话，让他赔偿是无可厚非的。个人理解：这里同样是用了使动的动词，与上一句中傷つけ也是类似的，也是一个很自然的事情吧。 (5)：自分が悪いのに逆切れしてる社員を叱らずにおかないぞ明明是自己的错还要反咬一口的职员肯定要被训斥的。个人理解：这里是用了被动的动词，这里没有用は，就是说ずにおかない也是可以的。 7. ａずにはすまない 、 ａないではすまない意味：ａの状態をけっして許さない字面翻译就是不a的话不能完成（不能结束、或者说要道歉），就是绝对不能允许a的发生或者状态，比较客观接続：動詞のない形＋ずにはすまない。動詞のない形＋ないではすまない。 例： (1)：父が入院したから、お見舞いにいかずにはすまない。父亲入院了，一定要去看望他。个人理解：表示一些必须要做，如社会氛围，伦理等让你必须去做的。如果不做就是不对的这样的程度。 (2)：人に迷惑をかけたら、あやまらずにはすまないと思うよ。给人带来麻烦的话，不道歉是不行的。个人理解：这个就是一些社会氛围和规则，道德上导致你必须做的事。 (3)：あの政治家は税金を私用に使ったわけだから、引退せずにはすまない。弹幕：这里面说的是比较像have to，也是客观地说这件事是不被允许的，不被接受的。 (4)：病院は生命に対する倫理意識がなければ、いろんな問題を引き起こさずには済まないだろう。病院如果没有生命伦理意识的话，一定会引起各种各样的问题吧。个人理解：这里有个双重否定，翻译是变成了肯定，双重否定就会是，不发生各种问题是不行的。中文里很怪。 8. ａを禁じ得ない意味：ａを我慢できない 不禁。。。 但是跟我不能忍受意味有点区别，更加主观接続：名詞＋を禁じ得ない 例： (1)：先生の変顔に笑いを禁じ得なかった。对着老师的鬼脸我不禁笑了理解：正常用法，禁じ得ない前面用名词性 (2)：日本の料理文化に対する海外での人気の高さに驚きを禁じ得ないよ。日本料理文化在海外的人气之高，不禁感到惊讶。理解：这里的不禁也是指个人感情，惊讶这件事情也是个人的想法。 (3)：こんなバカな行政政策に対して、今の国民たちは不満を禁じ得ないです。对于这样愚蠢的政策，现在的国民都不禁表达出不满。"},{"title":"激光SLAM学习 SLAM流程与回环检测","date":"2022-11-30T03:55:21.188Z","url":"/2022/11/30/SLAM/6_Mapping/","tags":[["SLAM","/tags/SLAM/"],["LOAM","/tags/LOAM/"],["机器学习","/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"]],"categories":[["undefined",""]],"content":"点云地图构建目前基于地图做定位是各种场景定位的解决方案，架构如前面图。前面讲述的关于前端里程计的主要是对原始数据(激光雷达是点云)，提取到特征后，通过构造的优化模型计算出其前后两帧之间的变化，从而实现位姿约束。还有里程计也是作为位姿的约束。RTK和组合导航是作为先验位置，也就是初始位姿作为一个输入，同时也能作为位姿约束输入。对于定位来说，只要有地图就是进行搜索和匹配，这部分对建图的流程和原理进行学习。剩下的部分就是组合导航和回环检测模块。 回环检测随着路径的不断延伸，机器人在建图过程中会存在一些累计误差，除了利用局部优化、全局优化等来调整之外，还可以利用回环检测来优化位姿。 回环检测是什么？回环检测，又称闭环检测，是指机器人识别曾到达某场景，使得地图闭环的能力。就是能够识别检测到它曾经到达过的地方，而不是作为新地图加入到地图中。地图生成时的误差会对定位造成非常大的影响，所以就算有RTK，纯靠RTK的定位误差也会使得地图变得糟糕。目的：它能够消除建图时产生的累计误差，提高地图一致性。方法：在历史帧中找到相似帧（位置相近且有充足共视视野的帧），给出两帧间的相对位姿。用法：在后端优化中，作为相对位姿约束边加入，加入图优化系统。 有初始相对位姿的情况下，使用ICP和NDT是这个课程中介绍过的方法。 后端优化目的：利用回环检测结果（与历史帧中相似帧的相对位姿）和惯导先验（也就是初始相对位姿）修正里程计的误差。 观测：1）连续两帧的相对位姿观测；（也就里程计，开环）2）回环匹配得到的相对位姿观测；3）组合导航提供先验位姿观测。 1，2组成基于回环；1、3组成基于先验"},{"title":"SLAM在农业机器人方面应用的论文阅读笔记","date":"2022-11-06T06:56:51.571Z","url":"/2022/11/06/Agriculture/Agriculture_paper/","tags":[["Agriculture","/tags/Agriculture/"],["Machinery","/tags/Machinery/"],["Paper Reading","/tags/Paper-Reading/"]],"categories":[["undefined",""]],"content":"该文主要是关于在期刊Computers_and_electroincs in agriculture上关键词SLAM的论文,提供后续论文的一些素材。根据之前读的一篇综述文章，将后续阅读的文章根据一下几个因素进行评估： （1）机械系统？（2）最终应用方向？（3）使用什么传感器？（4）使用了什么智能算法？（5）目前的发展状况？（研究阶段或商用）（6）应用区域？属于哪个国家和大洲？（7）弥补了什么缺点？还存在那些缺点0.Advances in Agriculture Robotics: A State-of-the-Art Review and Challenges Ahead摘要一直以来，农业机器人的目的都是为了克服人口增长、城市化加速、高质量产物的高适配性，保护环境以及合格劳动力的缺少带来的挑战。这篇文章回顾了农业机器人系统在播种、种植、植物处理、收获、产量估计和表型分析方面前的土地准备执行操作的主要现有应用。总的来说，所有机器人都通过以下几个因素进行评估：机械系统，最终应用，使用什么传感器，机械臂或视觉算法，发展状况以及属于哪个国家和大洲。评估了这些相似特征后，来发掘出研究的潮流，普遍存在的隐患以及与商业环境有关的特征。论文发现了目前智慧农业四个比较创新和潮流的方向：定位系统，传感器，视觉算法以及通信技术（自动驾驶也是同样的）。作者建议农业机器人系统投资短期目标为收获监控，长期目标为整体田野的评估。作者引用了另一篇文章中对精细农业的定义：a management strategy that uses electronic information and other technologies to gather, process, and analyze spatial and temporal data for the purpose of guiding targeted actions that improve efficiency, productivity, and sustainability of agricultural operations。一种利用电子信息和其他技术来收集、处理和分析空间和时间数据，以指导有针对性的行动，提高农业操作的效率、生产力和可持续性管理策略。分析了目前与精细农业相关的三个方面，机器人（robotics）、人工智能（artificial intelligence）和物联网（internet of things）。它们可以为农业任务提供保障，如：土地平整，播种，种植，害虫控制以及收获。 内容：机器人在农业中的应用关注本人目前的研究方向是水稻种植方面的农业机器人研究，仅对里面关于水稻田的机器人应用进行分析。 （1）在种植前的土地平整应用在这里面提及到了使用UAV Octocopter（无人八旋翼直升机），使用GPS,摄像头，加速计以及指南针作为导航传感器，用全向雷达作为障碍物感知。这里介绍的是大疆的MG-1P 系列农业植保机，现在已经停产了，更新一代的是T40农业无人飞机。它的优点是可以无视地形进行作业，而受到电池容量的限制以及风雨天气的影响较大。 （2）在播种和种植方面的应用根据不同的作物种类以及作业农场规模大小的不同，所使用的机器人差异巨大。与水稻播种相关的主要是两个机器人，一个是小麦播种的，用4WD的机械系统进行播种小麦播种机器人；而另外一个值得关注的是使用了卡尔曼滤波来矫正它的定位。Design of an autonomous seed planting robot 同时根据播种的机械装置也是不同的，有使用真空管+播种马达，也有使用线性的传动器和真空马达的，或者螺线管传动。 （3）在植物处理方面的应用在播种后的阶段，需要对植物的生长进行适当的维护，保证其免受疾病和害虫的侵害，需要对其进行监控。这方面的研究多使用相机或者深度相机作为传感器进行图片识别，利用人工智能算法区分杂草/无杂草，害虫/无害虫，能够早期发现这些异常进行处理。对水稻田研究的其中一种机器人是除草机器人，它能够在移动中除去杂草，通过高精度的图像处理，识别出它们的位置。首先避免植物（水稻）的碰撞，然后通过机械的方式在田间移动，能够在田里进行移动，并进行除草。 （4）在收获方面的应用在收获方面，绝大部分的收获所用的传感器都是用的RGB相机作为收获目标的识别，对于收获任务来说，只需要获得其目标所在的位置就可以，其余的机动状态是交给locomotion system。其中大部分都是关于长在树上或者植株上的收割，如草莓，椰子，苹果等，能够从背景中识别出来并使用机械臂进行抓取和脱离，完成收割任务。然而对于小麦、水稻等，是使用待收割区域，使用收割机完成收割任务。 1.3D global mapping of large-scale unstructured orchard integrating eye-in-hand stereo vision and SLAM （1）机械系统：4轮驱动移动平台以及采集用机械臂（2）最终应用方向：用于果树园林，执行收获任务（3）使用什么传感器：眼手系统，双目相机（立体声）-6自由度机械臂（4）使用了什么智能算法：ORB-SLAM3,efficientDet-D3（5）目前的发展状况：研究阶段（6）应用区域？属于哪个国家和大洲？中国广东的果园（7）解决问题/创新点：对大范围面积的果园进行了双目相机的地图建模，同时根据该地图进行定位和目标识别。 该论文使用立体声相机作为传感器，代替使用Lidar来作为建图和目标识别。目标识别不多介绍，他用的是efficientDet-D3用于目标识别。总体流程图如下图:首先是两个系统的校准，一个是相机内参，一个是机械臂系统和相机的相对关系。校准完后进行采样作为训练集、测试集。重要的详细部分是Local Dense Mapping。文中所说它的输入是去除背景后识别的目标，也就是bounding boxes。通过双目相机中对两张图片中识别到的视差图（disparity map）,得到每一个识别目标的局部视差图，将他们组成一个全局的视差图，再通过双边滤波器对边缘进行保留特征。 2.Design of a bistatic LIDAR system and simulating the performance for early detection of rice leaf blast from unmanned aircraft （1）机械系统：无人航行系统（2）最终应用方向：用于水稻田，执行植物处理方面任务，具体是疾病检测（3）使用什么传感器：LIDAR激光雷达、 EO/IR 光电红外技术（4）使用了什么智能算法：目前还没看到，是关于数据分析的（5）目前的发展状况：研究阶段（6）应用区域？属于哪个国家和大洲？未知（7）解决问题/创新点：使用激光雷达对二氧化碳浓度的检测 该论文提供了一种双基站的LIDAR以及基于无人飞行系统（UAS，Unmanned Aircraft Systems）的光电红外系统来对作物疾病的检测。通过搭建固定的激光雷达（Tx）和飞行系统上的激光雷达（Rx）组成双基站式的LIDAR系统，UAS一直面对着Tx进行接受，每个接收发送的两点组成一条线，每条线的时间，以及坐标都被记录下来。 3.A review on multirobot systems in agricultureAgricultural multirobot systems (MRSs) ，主要是对三种机器人进行分析UGV,UAV以及manipulators，我们关注UGV尤其是联合收割机在里面的review，里面对UGV的描述分为多个部分，下面逐一描述。 （1）四轮式的运动学模型（2）Multi UGV 多UGV协同"},{"title":"激光SLAM学习 LOAM代码","date":"2022-11-03T12:12:57.571Z","url":"/2022/11/03/SLAM/z_LOAM_code/","tags":[["SLAM","/tags/SLAM/"],["LOAM","/tags/LOAM/"],["机器学习","/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"]],"categories":[["undefined",""]],"content":"LOAM代码学习引自Github多传感器融合定位 三章 3D激光里程计2参考博客:slam中ceres的用法解析基于Aloam对特征匹配及雷达里程计的学习 引言该部分主要对ceres库在slam算法中的应用以及基本用法进行介绍和学习，作为以后自己参考的内容。Ceres``是由Google开发的开源C++通用非线性优化库（项目主页），与g2o并列为目前视觉SLAM中应用最广泛的优化算法库（VINS-Mono中的大部分优化工作均基于Ceres完成）。Ceres中的有限边界最小二乘问题建模为以下形式： \\underset{x}{min}\\frac 12 \\sum_{i}p_i(\\|f_i(x_{i1},x_{i2},...,x_{ik}) \\|^2)\\\\ s.t. l_j \\leq x_i \\leq u_j \\\\ 残差模块（residual block）： p_i(\\|f_i(x_{i1},x_{i2},...,x_{ik}) \\|^2) \\\\ 损失函数（loss function）：p_i(·)\\\\ 定义在单个样本上的，算的是一个样本的误差。\\\\ 参数模块（parameter blocks）：{x_{i1},x_{i2},...,x_{ik}} \\\\ 代价函数（cost function）：f_i(·)\\\\是定义在整个训练集上的，是所有样本误差的平均，也就是损失函数的平均。\\\\ l_j 和 u_j分别为参数模块的下界和上界Ceres的求解过程包括构建最小二乘和求解最小二乘问题两部分，其中构建最小二乘问题的相关方法均包含在Ceres::Problem类中，涉及的成员函数主要包括Problem::AddResidualBlock()和Problem::AddParameterBlock()。这里我们对于需要解决的问题，就需要对这两个函数里面的参数进行传递，并重定义它们。对LOAM来说，残差模块就是前面所对应的线面特征。 残差的含义在于两帧之间待优化变量它们的变化或者代表变化的变量。在代码中使用线面特征计算去表示其代价函数。损失函数则可以选用其他多种常见的损失函数。残差模块的概念是在ceres中才有的，下面结合代码来解释。 //新建一个损失函数为HuberLossceres::LossFunction loss_function = new ceres::HuberLoss(0.1);//新建一个参数模块为Eigen的四元数参数，LocalParameterization类的作用是解决非线性优化中的过参数化问题。所谓过参数化，即待优化参数的实际自由度小于参数本身的自由度。例如在SLAM中，当采用四元数表示位姿时，由于四元数本身的约束（模长为1），实际的自由度为3而非4。此时，若直接传递四元数进行优化，冗余的维数会带来计算资源的浪费，需要使用Ceres预先定义的QuaternionParameterization对优化参数进行重构：ceres::LocalParameterization q_parameterization =new ceres::EigenQuaternionParameterization();//新建一个Problem类，同时可以在Options中进行调整ceres::Problem::Options problem_options;ceres::Problem problem(problem_options);//通过Problem类添加参数模块，这里添加了四元数矩阵和旋转矩阵对应的参数，分别为四维（x,y,z,w)和三维(x,y,z)problem.AddParameterBlock(para_q, 4, q_parameterization);problem.AddParameterBlock(para_t, 3);//q_curr_last(x, y, z, w), t_curr_lastdouble para_q[4] = {0, 0, 0, 1};double para_t[3] = {0, 0, 0};//这里根据这个double数组来对其进行内存空间的分配//这里介绍一下Eigen::Map，括号()里面是实际数据存放的内存的指针，即para_q和para_t作为基本的指针结构传递进Map，用q_last_curr来表示，这里的意思只是重映射成一个成模板类中的类型作为分析，所以q_last_curr和para_q存储的是同一个数，t_last_curr和para_t也一样Eigen::Map q_last_curr(para_q);Eigen::Map t_last_curr(para_t); //新建一个代价函数，这里用的是面特征，这段代码是选取了面点ceres::CostFunction *cost_function = LidarPlaneFactor::Create(curr_point, last_point_a, last_point_b, last_point_c, s);//当代价函数和损失函数以及参数模块都准备好后，加入残差模块problem.AddResidualBlock(cost_function, loss_function, para_q, para_t);//使用求解器对该优化问题进行求解ceres::Solver::Options options;options.linear_solver_type = ceres::DENSE_QR;options.max_num_iterations = 4;options.minimizer_progress_to_stdout = false;ceres::Solver::Summary summary;ceres::Solve(options, &amp;problem, &amp;summary);通过problem类把参数模块已经传进去，求解后就可以得到参数变量的内存空间就更新了。 代码结构解读参考博客A-LOAM工程架构与代码详解代码是lidar_localization文件夹，它整个文件夹是ros中的一个package，首先看它的launch文件，启动了哪几个节点。分别启动了下面几个： scan_registration_node：原始点云的订阅和发布，每一帧线点和角点的计算 front_end_node（注释了） aloam_laser_odometry_node 基于线点和角点，计算他们帧与帧之间的关联关系 aloam_mapping_node evaluation_node这几个node中都存在一个while循环，逻辑是readdata然后检测validdata，然后updatedata，再PublishData。由上述代码可以知道，主要是四个模块。每个模块的cpp文件都由node，flow以及原始类组成。node是作为启动节点的cpp，而flow是作为流，个人理解是作为一个线程开启，具体的函数逻辑在原始类中。1. scan_registration_node在while循环中分为以下几个部分：（1）Readdata：这个函数将从cloud_sub_ptr（cloud_subsriber）的ParseData中获得，该函数使用地址传递，将点云数据传递到cloud_data_buff下面。（2）hasData：该函数判断是否有数据，从序列中获取最新的一帧。（3）Update：里面有三个函数，对获取的原始数据进行处理：// filter input point cloud:CloudData::CLOUD filtered_cloud;FilterByRange(input_cloud.cloud_ptr, filtered_cloud);这个函数是对min_range这个值外的点云进行处理，相当于不处理周围5米内的点// sort point cloud by scan,根据每个点所在的角度来获取它在哪一条线上，根据所在线来分类点云:output_cloud.reset(new CloudData::CLOUD());SortPointCloudByScan(filtered_cloud, output_cloud); // get feature points，这个函数是获得四种特征点的计算，包括曲率等:GetFeaturePoints(*output_cloud, corner_sharp, corner_less_sharp, surf_flat, surf_less_flat); 2.aloam_laser_odometry_node核心流程如下：这个函数是对从scan_registration_node里面获取的特征，包括cornerpoint和planepoint。首先对首帧进行初始化，对第二帧的点云，进行kdtree结构化构造。利用以下函数进行计算：kdtreeCornerLast-&gt;nearestKSearch(pointSel, 1, pointSearchInd, pointSearchSqDis); Parameters（参数）[in] point a given valid (i.e., finite) query point，这里指的是输入点的序列[in] k the number of neighbors to search for 这里指的是每个点要找的邻居点个数[out] k_indices the resultant indices of the neighboring points (must be resized to k a priori!) 输出的邻居点他们的序列号[out] k_sqr_distances the resultant squared distances to the neighboring points (must be resized to k a priori!) 输出的邻居点他们的距离从这函数可以看到，它找的是1个最近点，从这个点开始找所有的点，限制为往上3个点，向下3个点。面特征点也是一样的。这里找到了对应点所包含的线特征和面特征后，输入到前面所说的损失函数，进行求解。这样就完成了一次循环，再不断迭代。 3.aloam_mapping_node"},{"title":"激光SLAM学习 点云特征提取与位姿优化","date":"2022-10-27T07:59:19.173Z","url":"/2022/10/27/SLAM/5_Geometry_feature/","tags":[["Deep learning","/tags/Deep-learning/"],["SLAM","/tags/SLAM/"],["特征提取","/tags/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/"]],"categories":[["undefined",""]],"content":"点云线面特征提取参考博客：LOAM论文和程序代码的解读知乎：基于线面特征的激光里程计 按线数分割当给出的一帧点云中，所给的点不知道它属于哪根线时，可以根据激光点的坐标，计算该束激光相比于雷达水平面的倾角,根据内参倾角就可以计算得到： P = (x,y,z) \\\\ w = arctan \\frac{z}{\\sqrt{x^2+y^2}} 计算曲率根据同一条线面上前后各5个点与当前点的长度（长度指激光点到雷达的距离），计算曲率大小。 c= \\frac{1}{\\| x\\|}\\| \\sum_{i} (X - X_i) \\|这样我们可以在同一个平面内，按照曲率大小进行特征提取。 1.曲率特别大的点（sharp)这种情况下，这个线打到的实体表面应该如下图：可以由图看见，作者直观地展示曲率的大小，我用直线表示在各个点上，直线高度与曲率c成正比。越尖锐的点曲率越大，在直线上的点曲率则是，远比左右点的距离小，得到的曲率值是特别大的。而对于平面来说，他们之间的差距很小甚至没有，所以能得到其曲率为0。同样地，在不规则平面内可以显示：根据曲率值的大小，可以对点进行分类。论文中分成两类：曲率大的就是角点(sharp)，曲率小的是平面点（flat），或者说一条线上的点，作为特征进行匹配。这些特征要如何用于位姿估计和优化？ 基于线面特征的位姿优化1. 帧间关联1）点云位姿转换对于相邻两帧之间的相对位姿，即第k+1帧与第k帧的相对位姿为 T = \\begin{bmatrix} R & t \\\\ 0 & 1 \\end{bmatrix}从第k+1帧中的点#p_i#转到第k帧坐标系： \\tilde{p_i} = Rp_i+t2）特征关联对于所有的特征点，由于一帧内的点是在不同时间内扫出来的，将一帧内所有点先重投影到每一帧的最后的时刻，这样就能得到一帧中所有特征点的信息。特征点分为两类： 对于角点，一般在转折线上（例如卧室里的墙角），要计算它到折线的距离。作者认为，可以有如下假设：角点是雷达某个线束与物理世界两个平面夹角相交时的采样，那么这个线束相邻的雷达扫描线束也会与这个平面夹角相交，所以这个平面夹角的直线可以用前后两次扫描的角点进行标识。角点#p_i#在上一帧的坐标系转换为#\\tilde{p_i}#,在这个坐标系中找离它最近的线特征点a，并在相邻的线上再找一个线特征点b。这两个点就可以确定直线方程，就能够计算激光雷达到该直线的距离。我的理解是这样做可以把角点作为参考点，而这个线特征点a是当前的位置，线特征点b是上一帧的位置，利用环境稳定的特征点作为参考得到计算 对于平面点，一般在比较平坦的表面上（例如墙面），要计算它到平面的距离。与角点是差不多的，首先找上一帧中最近邻的平面点，之后在同一个扫描线数和不同的线束上各提取一个平面点，这样共得到了3个不共线的平面点，唯一确定了平面，从而计算平面点到平面的距离。 2. 残差函数由上图和我们的计算函数可知，我们可以计算其线特征（点到直线距离）和面特征（点到平面距离），并构造关于待求变量（T，相对位姿转换矩阵）的残差函数并建立其优化目的，即求特征点对与T的雅可比矩阵，进行优化。我们对于点云中的点到该直线的距离（线特征）可以由下式计算 d_{\\epsilon} = \\frac{|(\\tilde{p_i}-p_j)\\times(\\tilde{p_i}-p_l)|}{|p_l-p_j|}线特征的残差雅可比计算： J_{\\epsilon} = \\frac{\\partial d_{\\epsilon} }{\\partial T } = \\frac{\\partial d_{\\epsilon} }{\\partial \\tilde{p_i}} \\frac{\\partial \\tilde{p_i}}{\\partial T }对于等式右边第二项： 对平移的雅可比： \\frac{\\partial \\tilde{p_i} }{\\partial t } = I \\\\ 对旋转的雅可比： \\frac{\\partial \\tilde{p_i} }{\\partial R } = - (Rp_i)\\hat{} 第二项的雅可比为： \\frac{\\partial \\tilde{p_i} }{\\partial T } = \\begin{bmatrix} I & -(Rp+t)\\hat{} \\\\ 0^T & 0^T \\end{bmatrix} \\\\ 对于等式右边第一项，根据外积的微分得： \\\\ \\frac{\\partial d_{\\epsilon} }{\\partial \\tilde{p_i}} = \\frac{(p_a-p_b)\\hat{}}{|p_a-p_b|}而对于点到平面的距离（面特征）： d_{H} = (\\tilde{p_i}-p_j) \\cdot \\frac{|(p_l-p_j) \\times (p_m-p_j)|}{|(p_l-p_j) \\times (p_m-p_j)|}面特征的残差雅可比计算： J_{H} = \\frac{\\partial d_{H} }{\\partial T } = \\frac{\\partial d_{H} }{\\partial \\tilde{p_i}} \\frac{\\partial \\tilde{p_i}}{\\partial T } \\\\前面线特征已计算出等式右边第二项，第一项为： \\frac{\\partial d_{H} }{\\partial \\tilde{p_i}} = \\frac{|(p_l-p_j)\\times(p_m-p_j)|}{|(p_l-p_j)\\times(p_m-p_j)|}"},{"title":"激光SLAM学习 几何基础","date":"2022-10-27T06:23:32.157Z","url":"/2022/10/27/SLAM/4_Geometry/","tags":[["Deep learning","/tags/Deep-learning/"],["SLAM","/tags/SLAM/"],["几何","/tags/%E5%87%A0%E4%BD%95/"]],"categories":[["undefined",""]],"content":"几何基础在应用激光雷达算法之前，我们先对几何基础进行学习。 向量运算及其几何意义 内积内积，即数量积，点乘。定义如下： \\vec{a} = (x_1,y_1,z_1) \\vec{b} = (x_2,y_2,z_2) \\vec{a} \\cdot \\vec{b} = x_1x_2 + y_1y_2 + z_1z_2对于几何意义，则是a在b上的投影后的积： \\vec{a} \\cdot \\vec{b} = |{a}||{b}|\\cos{\\theta} 外积外积，即向量积，叉乘。定义如下： \\vec{a} = (x_1,y_1,z_1) \\\\ \\vec{b} = (x_2,y_2,z_2)\\\\ \\vec{a} \\times \\vec{b} = \\begin{bmatrix} i & j & k \\\\ x_1 & y_1 & z_1 \\\\ x_2 & y_2 & z_2 \\end{bmatrix}x_1x_2 + y_1y_2 + z_1z_2 \\\\ = (y_1z_2 - y_2z_1)i - (x_1z_2 - x_2z_1)j + (x_1y_2-x_2y_1)k对于几何意义，外积的模长则是a和b组成的平行四边形的面积： \\vec{a} \\times \\vec{b} = \\underbrace{|{\\vec{a}}|\\sin{\\theta}}_{高} |{\\vec{b}}| 外积的方向满足右手定则，由a和b张成平面的（单位）法向量n为： \\vec{n} = \\frac{\\vec{a} \\times \\vec{b} }{|\\vec{a} \\times \\vec{b}|} 微分性质对于内积微分有： \\frac{\\partial{\\vec{a} \\cdot \\vec{b}}}{\\partial{\\vec{a}}} = \\vec{b}对于外积微分有： \\vec{a} \\times \\vec{b} = \\hat{a} b其中[a]^为a的反对称矩阵。 \\hat{a} b = \\hat{[b]}a \\\\ \\frac{\\partial{\\hat{a} b}}{\\partial{\\vec{a}}} = -\\hat{[b]} 线面特征运算 点到直线的距离（平面内）点A到直线BC的距离为平行四边形面积除以对角线长度： |\\vec{AD}| = \\frac{|\\vec{AB} \\times \\vec{AC}|}{|\\vec{BC}|} 点到平面距离（空间内）首先要求出平面BCD的法向量，再求出该点与该平面与相交的线在法向量上的投影平面BCD的单位法向量为： \\vec{n} = \\frac{\\vec{BC} \\times \\vec{BD} }{|\\vec{BC} \\times \\vec{BD}|}然后点A到平面BCD的距离就可以由AB到法向量的投影求得： \\vec{AE} =|\\vec{AB}|\\cos{\\theta} = \\vec{AB} \\cdot \\vec{n} "},{"title":"激光SLAM学习 点云畸变补偿","date":"2022-10-25T13:05:12.337Z","url":"/2022/10/25/SLAM/3_Distortion/","tags":[["Deep learning","/tags/Deep-learning/"],["SLAM","/tags/SLAM/"],["畸变补偿","/tags/%E7%95%B8%E5%8F%98%E8%A1%A5%E5%81%BF/"]],"categories":[["undefined",""]],"content":"点云畸变补偿激光雷达通过发射激光束来测量周围环境物体的距离和方位，从而判断车辆与障碍物的相对位置。当其发射的激光束足够多时，这一个个的激光点将汇集成一片点云，勾勒出其所处的三维环境信息，这便是我们常说的点云数据。对于多数激光雷达而言，尽管激光的发射与接收很快，但构成点云的每一个点仍非同一时刻生成的。一般我们会将100ms (对应典型值10Hz) 内累积的数据作为一帧点云输出。若在这100ms内，激光雷达本体或安装所在的机体发生绝对位置的变化，那么此帧点云中每一个点的坐标系就是不同的。直观上看，这一帧点云数据就会发生一定的“变形”，不能真实对应所探测到的环境信息，类似于拍照时手抖了，拍出来的照片就会糊。这便是激光雷达的自运动畸变。引自知乎Livox 览沃激光雷达 自运动畸变由于激光雷达自身所在的载体坐标系发生改变时，会导致激光雷达坐标系运动，在一定时间内扫描的一圈不能闭合，包括旋转和平移，如下图：由图可知，平移会导致圆形的破坏，导致圆心的偏移；而旋转会导致部分的点相对于起始角有角度偏移。二者均会导致获得的点云产生畸变，在输入到SLAM前，对其纠正是必要的。 补偿方法需要对每个激光点坐标作补偿，补偿量为激光点原点（当时雷达的坐标）相对于起始时刻的变化，即计算时刻0（起始时刻）到时刻i（当前时刻）发生的旋转和平移变化。数学表示如下： 假设一帧点云中，起始时刻0雷达的位姿为： T_0 = \\begin{bmatrix} R_0 & t_0 \\\\ 0 & 1 \\end{bmatrix}在时刻i（第i帧），雷达的位姿为： T_i = \\begin{bmatrix} R_i & t_i \\\\ 0 & 1 \\end{bmatrix}第i个激光点的坐标为: P_i = \\begin{bmatrix} p_{ix} & p_{iy} & p_{iz} \\end{bmatrix}经过位姿测量，补偿后的激光点的坐标为: \\vec{P_i} = T_0^{-1}T_i P_i也可以通过平均角速度$w$和速度$v$来算出来对应的$R_i$和$t_i$: R_i = w d_{time} \\\\ t_i = v d_{time}该位姿变化可以使用角速度、线速度的输入，或者imu、编码器等外接传感器来计算其相对位姿，也可以使用slam的相对位姿（效果稍差）。 "},{"title":"激光SLAM学习 正态分布变换NDT","date":"2022-10-24T14:57:19.385Z","url":"/2022/10/24/SLAM/2_NDT/","tags":[["Deep learning","/tags/Deep-learning/"],["SLAM","/tags/SLAM/"],["NDT","/tags/NDT/"]],"categories":[["undefined",""]],"content":"正态分布变换 Normal Distribution Transformation正态分布是用于描述一个变量的概率分布中的一种，在SLAM中是将点云的分布用正态分布进行描述。其基本流程如下图：其概率指的是待匹配点云与目标点云他们栅格的点统计的数目，计算了均值，协方差就可构建其相关的正态分布。 问题描述 基于NDT的问题描述和输入描述如下：点集： X = \\{x_1,x_2, ... , x_{N_x}\\}Y = \\{y_1,y_2, ... , y_{N_y}\\}其中X和Y是原始点云的子集，选取的是两个点集中能够互相关联的点集，$N_x = N_y$目标函数： max \\Psi =max \\prod_{i=1}^{N_y} f(X,T(p,y_i))目标函数由原来的点到点之间的欧式距离计算变为了联合概率。f代表的是概率密度函数，X代表的是待匹配点集,$T(P,Y_i)$代表的是其空间转换函数，其中p代表的姿态变换，用于对$y_i$进行移动。 对于2D模型：$p = p_3 = [t_x t_y \\phi _z]^T$ 对于3D模型：$p = p_6 = [t_x t_y t_z \\phi _x \\phi _y \\phi _z]^T$ 概率模型计算对于点云概率分布的计算，需要计算其均值和协方差。 均值： \\mu = \\frac{1}{N_x} \\sum_{i=1}^{N_x} x_i \\\\ 协方差： E = \\frac{N_x -1}{1} \\sum_{i=1}^{N_x} (x_i - \\mu) (x_i - \\mu)^T对于目标函数中的预测的位姿，根据初始值R和t对点进行旋转平移得到Y,获得在同一坐标系下的X和Y。 预测值: $y\\prime _i = T(p,y_i) = Ry_i + t$根据定义即可计算各点的联合概率： f(X,y\\prime _i) = \\frac{1} {\\sqrt{2\\pi}\\sqrt{|E|}} exp(-\\frac{(y\\prime _i-\\mu)^TE^{-1}(y\\prime _i-\\mu)}{2})所有点的联合概率： \\begin{equation} \\begin{split} \\Phi &= \\prod_{i=1}^{N_y} f(X,T(p,y_i)) \\\\ &= \\prod_{i=1}^{N_y} \\frac{1} {\\sqrt{2\\pi}\\sqrt{|E|}} exp(-\\frac{(y\\prime _i-\\mu)^TE^{-1}(y\\prime _i-\\mu)}{2}) \\\\ \\end{split} \\nonumber \\end{equation}取对数,最后一项为常数： ln \\Phi = \\sum_{i=1}^{N_y}(-\\frac{(y\\prime _i-\\mu)^TE^{-1}(y\\prime _i-\\mu)}{2}+ln(\\frac{1} {\\sqrt{2\\pi}\\sqrt{|E|}}))所以目标函数则可以转化为： max \\Psi = max ln\\Psi = min\\sum_{i=1}^{N_y}(y\\prime _i-\\mu)^TE^{-1}(y\\prime _i-\\mu)由该目标函数中可以定义出残差函数$f_i(p)=y\\prime _i-\\mu$,根据高斯牛顿法进行计算，残差函数关于待求参数的雅可比，便可迭代优化。 J_i = \\frac{dp}{df_i(p)}这里的p其实就是前面的姿态变换矩阵，对其求偏导，对于2D模型的求导过程如下： p = p_3 = [t_x t_y \\phi _z]^T \\\\ \\begin{equation} \\begin{split} y\\prime _i &= T(p,y_i) \\\\ &= \\begin{bmatrix} cos \\phi _z & -sin \\phi _z \\\\ sin \\phi _z & cos \\phi _z \\end{bmatrix} y_i + \\begin{bmatrix} t_x \\\\ t_y \\end{bmatrix} \\end{split} \\nonumber \\end{equation}\\\\ 雅可比矩阵J_i = \\begin{bmatrix} 1 & 0 & -y_{i1} sin \\phi _z - -y_{i2} cos \\phi _z\\\\ 0 & 1 & y_{i1} cos \\phi _z - -y_{i2} sin \\phi _z \\end{bmatrix} 三维场景下同样能求出对应的雅可比矩阵，这里用图进行表示： 代码："},{"title":"激光SLAM学习 迭代最近邻点算法","date":"2022-10-24T07:51:41.516Z","url":"/2022/10/24/SLAM/1_ICP/","tags":[["AI","/tags/AI/"],["Deep learning","/tags/Deep-learning/"],["SLAM","/tags/SLAM/"]],"categories":[["undefined",""]],"content":"迭代最近邻点算法 Iterative Closest Point该方法为最简单暴力的匹配算法，根据问题描述中的目标函数，对目标函数进行推导。 问题描述 前端里程计的问题描述和输入描述如下：点集： X = \\{x_1,x_2, ... , x_{N_x}\\}Y = \\{y_1,y_2, ... , y_{N_y}\\}其中X和Y是原始点云的子集，选取的是两个点集中能够互相关联的点集，$N_x = N_y$目标函数： minE(R,T)=min\\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|x_i - Ry_i - t\\|^2其中R和T分别为旋转矩阵和平移矩阵，E代表均方差。求得R和T使得他们的欧式距离的均方差E最小，这是最基本的目标函数。 （1）基于奇异值分解（SVD）的ICPSVD的方法首先第一步将加了几部分进来，进行转变 \\begin{equation} \\begin{split} E(R,T) &= \\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|x_i - Ry_i - t + -u_x + Ru_y +u_x - Ru_y \\|^2 \\\\ &= \\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|x_i -u_x - R(y_i - u_y)+ (u_x - Ru_y - t )\\|^2 \\\\ & 这里根据平方差公式展开\\\\ &= \\frac{1}{N_y} \\sum_{i=1}^{N_y} (\\|x_i -u_x - R(y_i - u_y)\\|^2 + \\|(u_x - Ru_y - t )\\|^2 \\\\ & +2(x_i -u_x - R(y_i - u_y))^T(u_x - Ru_y - t )) \\end{split} \\nonumber \\end{equation}其中$u_x$和$u_y$分别是点集X和Y的质心，即 u_x = \\frac{1}{N_x} \\sum_{i=1}^{N_x} x_i \\\\ u_y = \\frac{1}{N_y} \\sum_{i=1}^{N_y} y_i结合前面的求和可知$x_i -u_x - R(y_i - u_y)$项为0，E(R,T)变为如下 E(R,T) = \\frac{1}{N_y} \\sum_{i=1}^{N_y} (\\|x_i -u_x - R(y_i - u_y)\\|^2 + \\|(u_x - Ru_y - t )\\|^2)将其拆分为两部分： E_1(R,T) = \\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|x_i -u_x - R(y_i - u_y)\\|^2 \\\\ E_2(R,T) = \\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|(u_x - Ru_y - t )\\|^2 由$E_2$的性质可知，对于任意的一个R，都可以找到一个t使得$u_x - Ru_y - t = 0$，所以不需要求$E_2$，只需要求$E_1$，得到R之后，自然得到t。对$E_1$进行推导: \\begin{equation} \\begin{split} E\\prime _1(R,T) &= \\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|x_i -u_x - R(y_i - u_y)\\|^2 \\\\ &= \\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|x\\prime _i - R(y\\prime _i)\\|^2 \\\\ &= \\frac{1}{N_y} \\sum_{i=1}^{N_y} ( x\\prime _i^T x\\prime _i+ y\\prime _i^T R^T Ry\\prime _i - 2x\\prime _i^T Ry\\prime _i) \\end{split} \\nonumber \\end{equation} 该式中，第一项与R无关，而第二项二单位阵，只与第三项有关，则目标函数变为： \\begin{equation} \\begin{split} E\\prime _1(R,t) &= arg\\underset {R}{max} \\sum_{i=1}^{N_y} x\\prime _i^T Ry\\prime _i \\\\ &= arg\\underset {R}{max} \\sum_{i=1}^{N_y} Trace(x\\prime _i^T Ry\\prime _i) \\\\ & 由 trace(AB) = trace(BA) \\\\ &= arg\\underset {R}{max} \\sum_{i=1}^{N_y} Trace(Ry\\prime _i x\\prime _i^T ) \\\\ &= arg\\underset {R}{max} Trace(RH) \\\\ 其中H = \\sum_{i=1}^{N_y} y\\prime _i x\\prime _i^T \\end{split} \\nonumber \\end{equation} 至此，需要对该矩阵转变为正定矩阵，并进行分解定理：若存在正定矩阵$AA^T$,一定存在任意正交矩阵B，使得$Trace(AA^T) \\geq Trace(BAA^T) $意义：若能找到R，使得RH变为正定矩阵，则找到最大值，满足目标函数 对H进行奇异值分解： H = UEV^T = y\\prime _i x\\prime _i^T\\\\ 若R = VU^T \\\\ 则RH = VU^T UE V^T =VE V^T = VE^{\\frac 12} (VE^{\\frac 12})^T在这里其实由H的定义可知U即$y\\prime _i$,V即$x\\prime _i^T$。 接下来我们对实现代码进行讲解 （2）基于凸优化的ICP首先对凸优化本身进行一些基础讲解，它对什么样的问题有进行什么操作？ 凸优化基础 优化任务的目标凸优化是对n维的变量$x^* \\in \\frak{R} ^n$，使得损失函数F(x)取得局部最小值： \\underset {x}{min} F(x) = \\frac 12 \\|f(x) \\|_2^2局部最小值指对任意的$|x - x^ | &lt; \\sigma $，都有$F(x^) \\leq F(x) $, F(x)代表的是损失函数，用以衡量真实值 y和预测值 f(x)之间不一致的程度，一般越小越好。为了便于不同损失函数的比较，常将其表示为单变量的函数，即关于f(x)的表达式作为残差函数，这个残差函数可以代表预测和观测,也可以是匹配的时候的点的距离，可以由多个残差函数组成。 迭代方法的思路 给定初值$x_0$； 对于第k次迭代，寻找增量$\\Delta x_k$，使得$|x_k + \\Delta x_k |_2^2$达到极小值; 如果达到足够小的值，则停止；否则返回第2步，继续迭代。 迭代下降求解优化的方法对损失函数进行泰勒展开可以得到： F(x + \\Delta x) \\approx F(x) + J \\Delta x + \\frac 12 \\Delta x^T H \\Delta x其中J为X的一阶导（雅可比矩阵，Jacobian），H为X的二阶导（海森矩阵，Hessian） 最速下降法 只保留一阶泰勒展开，增量$\\Delta x^* = -J^T$,沿梯度的反方向取增量，保证损失函数减少。优点: 简单、迭代方便缺点：精度有限、接近目标值时会下降变慢 牛顿法 保留二阶泰勒展开，增量方程为 \\Delta x^* = argmin (F(x) + J\\Delta x + \\frac 12 \\Delta x^TH\\Delta x求其最小值即求该方程的导数为0，即 J^T + H\\Delta x = 0 \\Rightarrow H\\Delta x = -J^T优点: 更精确，每一步收敛更准确；收敛速度快缺点：当规模变大时，H矩阵的计算比较难 高斯牛顿法 原先是对其损失函数即残差函数的一个二范数求最小值，而高斯牛顿法是直接对残差函数进行泰勒展开，同时保留其一阶导求雅可比矩阵：问题变为寻找增量$\\Delta x$使得$| f(x+\\Delta x)|^2$达到最小： \\Delta x^* = arg\\underset {\\Delta x}{min} \\frac 12 \\| f(x + J\\Delta x)\\|^2同样地，需要对其求导且导数为0的情况下为最小，展开为： \\begin{equation} \\begin{split} \\frac 12 \\| f(x + J\\Delta x)\\|^2 &= \\frac 12(f(x) + J\\Delta x)^T(f(x) + J\\Delta x) \\\\ &= \\frac 12( \\| f(x) \\|_2^2 + 2f(x)J\\Delta x + \\Delta x^T J^T J \\Delta x ) \\end{split} \\end{equation}对其求导并令其为0，则得到 \\underbrace{J^T f(x)}_{g} + \\underbrace{J^T J}_{H} \\Delta x = 0 \\\\ 即 \\Delta x = H^{-1}g优点: 用$J^TJ$代替牛顿法中的H，则不需要二阶导数缺点：但是求解必须保证H矩阵是可逆的，而$J^TJ$只能保证半正定，算法稳定性变差，最终难以收敛。 在SLAM中的凸优化 基于凸优化的ICP问题，我们将原来的目标函数重新说明一下： minE(R,t)=min\\frac{1}{N_y} \\sum_{i=1}^{N_y} \\|x_i - Ry_i - t\\|^2使用矩阵T对R和t进行表示： T = \\quad \\begin{bmatrix} R & t \\\\ 0 & 1 \\end{bmatrix}目标函数变为: \\underset{T}{min} \\frac 12 \\sum_{i=1}^{N_y} \\|x_i - Ty_i\\|_2^2还有相对应的李代数变换，目前还不会先不记录了。接下来我们对实现代码进行讲解: "},{"title":"Cmd Markdown 公式指导手册","date":"2022-10-24T06:14:21.731Z","url":"/2022/10/24/tools/mathjax_tutorial_mdeditor_220713/","tags":[["Markdown","/tags/Markdown/"]],"categories":[["undefined",""]],"content":" 本文为 MathJax 在 Cmd Markdown 环境下的常用语法指引。Cmd Markdown 编辑阅读器支持 $\\LaTeX$ 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$，访问 MathJax 以参考更多使用方法。 右键点击每一个公式，选择 [Show Math As] → [TeX Commands] 以查看该公式的命令详情。 [TOC] 一、公式使用参考1．如何插入公式$\\TeX$ 可使用行中公式放在文中与其它文字混编，或单独成行的独立公式。 行中公式可以用如下方法表示： : $ 表达式 $ 独立公式可以用如下方法表示： : 表达式 自动编号的公式可以用如下方法表示：: 若需要手动编号，可在公式后使用 \\tag&#123;编号&#125; 语句。 : \\begin{equation} 表达式 \\label{eq:当前公式名}\\end{equation} : 自动编号后的公式可在全文任意处使用 \\eqref&#123;eq:公式名&#125; 语句引用。 例子： 显示： $ J\\alpha(x) = \\sum{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，行内公式示例} $ 例子： 显示： J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text{，独立公式示例，使用 \\tag 手动编号} \\tag{0.1} 例子： 显示： 在公式 \\eqref{eq:sample} 中，我们看到了这个被自动编号的公式。\\begin{equation} E=mc^2 \\text{，自动编号公式示例} \\label{eq:sample}\\end{equation} 不自动编号的公式可以用如下方法表示： : \\begin{equation} 表达式\\end{equation} 2．如何输入上下标^ 表示上标，_ 表示下标。如果上下标的内容多于一个字符，需要用 &#123;&#125; 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。 例子： 显示：x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} 如果要在左右两边都有上下标，可以使用 \\sideset 命令；也可以简单地在符号前面多打一个上下标，此时会以行内公式渲染。本例内 \\quad 均为空格符号，为方便公式格式对比而添加，请注意辨别。详见在字符间加入空格。 例子： 显示：\\sideset{^1_2}{^3_4}\\bigotimes \\quad or \\quad {^1_2}\\bigotimes {^3_4} 3．如何输入括号和分隔符()、[] 和 | 表示符号本身，使用 \\&#123;\\&#125; 来表示 &#123;&#125; 。当要显示大号的括号或分隔符时，要用 \\left 和 \\right 命令。 一些特殊的括号：|输入|显示|输入|显示||—:|:—|—:|:—||\\langle|$\\langle$|\\rangle|$\\rangle$||\\lceil|$\\lceil$|\\rceil|$\\rceil$||\\lfloor|$\\lfloor$|\\rfloor|$\\rfloor$||\\lbrace|$\\lbrace$|\\rbrace|$\\rbrace$||\\lvert|$\\lvert$|\\rvert|$\\rvert$||\\lVert|$\\lVert$|\\rVert|$\\rVert$| @lymd 有时，我们需要在行内使用两个竖杠表示向量间的某种空间距离，可以这样写 \\lVert \\boldsymbol&#123;X&#125;_i - \\boldsymbol&#123;S&#125;_j \\rVert^2 → $\\lVert \\boldsymbol{X}_i - \\boldsymbol{S}_j \\rVert^2$ 例子： 显示：f(x,y,z) = 3y^2z \\left( 3+\\frac{7x+5}{1+y^2} \\right) 4．如何输入分数通常使用 \\frac &#123;分子&#125; &#123;分母&#125; 来生成一个分数，分数可多层嵌套。若分数只有一层，也可使用 分子 \\over 分母 命令。例内 \\quad \\mid \\, 等均为空格或分隔符号，为方便公式格式对比而添加，请注意辨别。详见在字符间加入空格。 例子： 显示：\\frac{a-1}{b-1} \\quad or \\quad {a+1 \\over b+1} 当分式 仅有两个字符时 可直接输入 \\frac ab 来快速生成一个 $\\Large\\frac ab$ 。 例子： 显示：\\frac 12,\\frac 1a,\\frac a2 \\quad \\mid \\quad \\text{2 letters only:} \\quad \\frac 12a \\,, k\\frac q{r^2} 5．如何输入开方使用 \\sqrt [根指数，省略时为2] &#123;被开方数&#125; 命令输入开方。本例内 \\quad 均为空格符号，为方便公式格式对比而添加，请注意辨别。详见在字符间加入空格。 例子： 显示：\\sqrt{2} \\quad or \\quad \\sqrt[n]{3} 6．如何输入省略号数学公式中常见的省略号有两种，\\ldots 表示与 文本底线 对齐的省略号，\\cdots 表示与 文本中线 对齐的省略号。 例子： 显示：f(x_1,x_2,\\underbrace{\\ldots}_{\\rm ldots} ,x_n) = x_1^2 + x_2^2 + \\underbrace{\\cdots}_{\\rm cdots} + x_n^2 7．如何输入向量使用 \\vec&#123;向量&#125; 来自动产生一个向量。也可以使用 \\overrightarrow 等命令自定义字母上方的符号。例内 \\quad \\mid \\, 等均为空格或分隔符号，为方便公式格式对比而添加，请注意辨别。详见在字符间加入空格。 例子： 显示：\\vec{a} \\cdot \\vec{b}=0 例子： 显示：xy \\text{ with arrows:} \\quad \\overleftarrow{xy} \\; \\mid \\; \\overleftrightarrow{xy} \\; \\mid \\; \\overrightarrow{xy} 8．如何输入积分使用 \\int_积分下限^积分上限 &#123;被积表达式&#125; 来输入一个积分。 例子：显示：\\int_0^1 {x^2} \\,{\\rm d}x 本例中 \\, 和 &#123;\\rm d&#125; 部分可省略，但加入能使式子更美观，详见在字符间加入空格及如何进行字体转换。 9．如何输入极限运算使用 \\lim_&#123;变量 \\to 表达式&#125; 表达式 来输入一个极限。如有需求，可以更改 \\to 符号至任意符号。 例子：显示：\\lim_{n \\to \\infty} \\frac{1}{n(n+1)} \\quad and \\quad \\lim_{x\\leftarrow{示例}} \\frac{1}{n(n+1)} 10．如何输入累加、累乘运算使用 \\sum_&#123;下标表达式&#125;^&#123;上标表达式&#125; &#123;累加表达式&#125; 来输入一个累加。与之类似，使用 \\prod \\bigcup \\bigcap 来分别输入累乘、并集和交集，更多符号可参考“其它特殊字符”。 此类符号在行内显示时上下标表达式将会移至右上角和右下角，如 \\sum_&#123;i=1&#125;^n \\frac&#123;1&#125;&#123;i^2&#125; 显示为 $\\sum_{i=1}^n \\frac{1}{i^2}$ ； 或： @woria 在行内可使用 \\sum\\limits_&#123;下标表达式&#125;^&#123;上标表达式&#125; &#123;累加表达式&#125; 使上下标仍在正上正下方。 如 \\sum\\limits_&#123;i=1&#125;^n \\frac&#123;1&#125;&#123;i^2&#125; 显示为 $\\sum\\limits_{i=1}^n \\frac{1}{i^2}$ 。 本例内 \\quad 均为空格符号，为方便公式格式对比而添加，请注意辨别。详见在字符间加入空格。 例子： 显示：\\sum_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\prod_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\bigcup_{i=1}^{2} \\Bbb{R} 11．如何输入希腊字母输入 \\小写希腊字母英文全称 和 \\首字母大写希腊字母英文全称 来分别输入小写和大写希腊字母。对于大写希腊字母与现有字母相同的，直接输入大写字母即可。 输入 显示 输入 显示 输入 显示 输入 显示 \\alpha $\\alpha$ A $A$ \\beta $\\beta$ B $B$ \\gamma $\\gamma$ \\Gamma $\\Gamma$ \\delta $\\delta$ \\Delta $\\Delta$ \\epsilon $\\epsilon$ E $E$ \\zeta $\\zeta$ Z $Z$ \\eta $\\eta$ H $H$ \\theta $\\theta$ \\Theta $\\Theta$ \\iota $\\iota$ I $I$ \\kappa $\\kappa$ K $K$ \\lambda $\\lambda$ \\Lambda $\\Lambda$ \\mu $\\mu$ M $M$ \\nu $\\nu$ N $N$ \\xi $\\xi$ \\Xi $\\Xi$ o $o$ O $O$ \\pi $\\pi$ \\Pi $\\Pi$ \\rho $\\rho$ P $P$ \\sigma $\\sigma$ \\Sigma $\\Sigma$ \\tau $\\tau$ T $T$ \\upsilon $\\upsilon$ \\Upsilon $\\Upsilon$ \\phi $\\phi$ \\Phi $\\Phi$ \\chi $\\chi$ X $X$ \\psi $\\psi$ \\Psi $\\Psi$ \\omega $\\omega$ \\Omega $\\Omega$ 部分字母有变量专用形式，以 \\var- 开头。 小写形式 大写形式 变量形式 显示 \\epsilon E \\varepsilon $\\epsilon \\mid E \\mid \\varepsilon$ \\theta \\Theta \\vartheta $\\theta \\mid \\Theta \\mid \\vartheta$ \\rho P \\varrho $\\rho \\mid P \\mid \\varrho$ \\sigma \\Sigma \\varsigma $\\sigma \\mid \\Sigma \\mid \\varsigma$ \\phi \\Phi \\varphi $\\phi \\mid \\Phi \\mid \\varphi$ 12．如何输入其它特殊字符 完整的 $\\LaTeX$ 可用符号列表可以在 这份文档 中查阅（极长，共 348 页），大部分常用符号可以参阅 这份精简版文档 查询。需要注意的是，$\\LaTeX$ 符号并不保证在 MathJax v2.2 中可用，即在 Cmd Markdown 编辑阅读器中可能并不支持所输入的特定命令。 若需要显示更大或更小的字符，在符号前插入 \\large 或 \\small 命令。MathJax 针对任意元素均提供从小至大 \\tiny \\Tiny \\scriptsize \\small *默认值 \\normalsize \\large \\Large \\LARGE \\huge \\Huge 共十种渲染大小，详见官方文档。 若找不到需要的符号，推荐使用 $\\large\\rm{Detexify}$ 来画出想要的符号 (1)．关系运算符 输入 显示 输入 显示 输入 显示 输入 显示 \\pm $\\pm$ \\times $\\times$ \\div $\\div$ \\mid $\\mid$ \\nmid $\\nmid$ \\cdot $\\cdot$ \\circ $\\circ$ \\ast $\\ast$ \\odot $\\odot$ \\otimes $\\otimes$ \\oplus $\\oplus$ \\leq $\\leq$ \\geq $\\geq$ \\neq $\\neq$ \\approx $\\approx$ \\equiv $\\equiv$ \\sum $\\sum$ \\prod $\\prod$ \\coprod $\\coprod$ \\backslash $\\backslash$ (2)．集合运算符 输入 显示 输入 显示 输入 显示 \\emptyset $\\emptyset$ \\in $\\in$ \\notin $\\notin$ \\subset $\\subset$ \\supset $\\supset$ \\subseteq $\\subseteq$ \\supseteq $\\supseteq$ \\cap $\\cap$ \\cup $\\cup$ \\vee $\\vee$ \\wedge $\\wedge$ \\uplus $\\uplus$ \\top $\\top$ \\bot $\\bot$ \\complement $\\complement$ (3)．对数运算符 输入 显示 输入 显示 输入 显示 \\log $\\log$ \\lg $\\lg$ \\ln $\\ln$ (4)．三角运算符 输入 显示 输入 显示 输入 显示 \\backsim $\\backsim$ \\cong $\\cong$ \\angle A $\\angle A$ \\sin $\\sin$ \\cos $\\cos$ \\tan $\\tan$ \\csc $\\csc$ \\sec $\\sec$ \\cot $\\cot$ (5)．微积分运算符 输入 显示 输入 显示 输入 显示 \\int $\\int$ \\iint $\\iint$ \\iiint $\\iiint$ \\partial $\\partial$ \\oint $\\oint$ \\prime $\\prime$ \\lim $\\lim$ \\infty $\\infty$ \\nabla $\\nabla$ (6)．逻辑运算符 输入 显示 输入 显示 输入 显示 \\because $\\because$ \\therefore $\\therefore$ \\neg $\\neg$ \\forall $\\forall$ \\exists $\\exists$ \\not\\subset $\\not\\subset$ \\not&lt; $\\not&lt;$ \\not&gt; $\\not&gt;$ \\not= $\\not=$ @xiaobanni \\vdash 显示为 $\\vdash$ (7)．戴帽符号 输入 显示 输入 显示 输入 显示 \\hat{xy} $\\hat{xy}$ \\widehat{xyz} $\\widehat{xyz}$ \\bar{y} $\\bar{y}$ \\tilde{xy} $\\tilde{xy}$ \\widetilde{xyz} $\\widetilde{xyz}$ \\acute{y} $\\acute{y}$ \\breve{y} $\\breve{y}$ \\check{y} $\\check{y}$ \\grave{y} $\\grave{y}$ \\dot{x} $\\dot{x}$ \\ddot{x} $\\ddot{x}$ \\dddot{x} $\\dddot{x}$ 若需要在特定文字顶部\\底部放置内容，可使用 \\overset&#123;顶部内容&#125;&#123;正常内容&#125; 和 \\underset&#123;底部内容&#125;&#123;正常内容&#125; 命令。例内 \\qquad \\quad \\mid \\; \\, 等均为空格或分隔符号，为方便公式格式对比而添加，请注意辨别。详见在字符间加入空格。 例子： 显示： \\verb+\\overset{above}{level}+ \\qquad \\overset{xx}{ABC} \\;\\; \\mid \\quad \\overset{x^2}{\\longmapsto}\\ \\, \\mid \\quad \\overset{\\bullet\\circ\\circ\\bullet}{T} 例子： 显示：\\verb+\\underset{below}{level}+ \\qquad \\underset{xx}{ABC} \\;\\; \\mid \\quad \\underset{x^2}{\\longmapsto}\\ \\, \\mid \\quad \\underset{\\bullet\\circ\\circ\\bullet}{T} 此命令可叠加嵌套使用，生成类似化学反应式的多重条件符号，如 \\overset&#123;H_2&#125;&#123;\\underset&#123;1300℃&#125;&#123;\\Longleftrightarrow&#125;&#125;： \\rm{SrO+V^{''}_{Sr} \\overset{H_2}{\\underset{1300℃}{\\Longleftrightarrow}} Sr^{\\times}_{Sr}+2e^{'}+\\frac 12O_2(g)} $$ 和 `\\overset{Surface/bulk}{\\underset{diffusion}{\\longleftrightarrow}}`： $$ \\rm{2OH^{\\circ}_{O(STN)}+2O^{\\times}_{O(YSZ)} \\; \\overset{Surface/bulk}{\\underset{diffusion}{\\longleftrightarrow}} \\;\\; 2OH^{\\circ}_{O(YSZ)}+2O^{\\times}_{O(STN)}}在书写化学方程式时可声明 \\require&#123;AMDcd&#125; 语句，使用 MathJax 内置的交换图表功能，具体例子可参见下文。 (8)．连线符号其它可用的文字修饰符可参见官方文档 “Additional decorations”。 输入 显示 \\fbox{a+b+c+d} 高级框选需声明 enclose 标签 $\\fbox{a+b+c+d}$ \\overleftarrow{a+b+c+d} $\\overleftarrow{a+b+c+d}$ \\overrightarrow{a+b+c+d} $\\overrightarrow{a+b+c+d}$ \\overleftrightarrow{a+b+c+d} $\\overleftrightarrow{a+b+c+d}$ \\underleftarrow{a+b+c+d} $\\underleftarrow{a+b+c+d}$ \\underrightarrow{a+b+c+d} $\\underrightarrow{a+b+c+d}$ \\underleftrightarrow{a+b+c+d} $\\underleftrightarrow{a+b+c+d}$ \\overline{a+b+c+d} $\\overline{a+b+c+d}$ \\underline{a+b+c+d} $\\underline{a+b+c+d}$ \\overbrace{a+b+c+d}^{Sample} $\\overbrace{a+b+c+d}^{Sample}$ \\underbrace{a+b+c+d}_{Sample} $\\underbrace{a+b+c+d}_{Sample}$ \\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0} $\\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0}$ \\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}} $\\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}}$ (9)．箭头符号 推荐使用符号：|输入|显示|输入|显示|输入|显示||:—:|:—:|:—:|:—:|:—:|:—:||\\to|$\\to$|\\mapsto|$\\mapsto$|\\underrightarrow{1℃/min} | $\\underrightarrow{1℃/min}$ ||\\implies|$\\implies$|\\iff|$\\iff$|\\impliedby|$\\impliedby$| 其它可用符号：|输入|显示|输入|显示||:—:|:—:|:—:|:—:||\\uparrow|$\\uparrow$|\\Uparrow|$\\Uparrow$||\\downarrow|$\\downarrow$|\\Downarrow|$\\Downarrow$||\\leftarrow|$\\leftarrow$|\\Leftarrow|$\\Leftarrow$||\\rightarrow|$\\rightarrow$|\\Rightarrow|$\\Rightarrow$||\\leftrightarrow|$\\leftrightarrow$|\\Leftrightarrow|$\\Leftrightarrow$||\\longleftarrow|$\\longleftarrow$|\\Longleftarrow|$\\Longleftarrow$||\\longrightarrow|$\\longrightarrow$|\\Longrightarrow|$\\Longrightarrow$||\\longleftrightarrow|$\\longleftrightarrow$|\\Longleftrightarrow|$\\Longleftrightarrow$| 13．如何进行字体转换若要对公式的某一部分字符进行字体转换，可以用 &#123;\\字体 &#123;需转换的部分字符&#125;&#125; 命令，其中 \\字体 部分可以参照下表选择合适的字体。一般情况下，公式默认为斜体字 $italic$ 。 示例中 全部大写 的字体仅大写可用。 输入 全字母可用 显示 输入 仅大写可用 显示 \\rm 罗马体 $\\rm{Sample}$ \\mathcal 花体（数学符号等） $\\mathcal{SAMPLE}$ \\it 斜体 $\\it{Sample}$ \\mathbb 黑板粗体（定义域等） $\\mathbb{SAMPLE}$ \\bf 粗体 $\\bf{Sample}$ \\mit 数学斜体 $\\mit{SAMPLE}$ \\sf 等线体 $\\sf{Sample}$ \\scr 手写体 $\\scr{SAMPLE}$ \\tt 打字机体 $\\tt{Sample}$ \\cal 等同于 \\mathcal $\\cal{ABCXYZ}$ \\frak 旧德式字体 $\\frak{Sample}$ \\Bbb 等同于 \\mathbb $\\Bbb{ABCXYZ}$ @lymd \\boldsymbol&#123;\\alpha&#125; 用来表示向量或者矩阵的加粗斜体，如向量 $\\boldsymbol{\\vec\\alpha}$ 。 转换字体十分常用，例如在积分中： 例子： 显示：\\begin{array}{cc} \\mathrm{Bad} &amp; \\mathrm{Better} \\ \\hline \\ \\int_0^1 x^2 dx &amp; \\int_0^1 x^2 \\,{\\rm d}x\\end{array} 注意比较两个式子间 $dx$ 与 ${\\rm d} x$ 的不同。使用 \\operatorname 命令也可以达到相同的效果，详见定义新的运算符。 14．如何高亮一行公式使用 \\bbox[底色, (可选)边距, (可选)边框 border: 框宽度 框类型 框颜色] 命令来高亮一行公式。底色和框颜色支持详见“更改文字颜色”，边距及框宽度支持 绝对像素 px 或 相对大小 em，框类型支持 实线 solid 或 虚线 dashed。 例子： 显示： \\bbox[yellow]{ e^x=\\lim_{n\\to\\infty} \\left( 1+\\frac{x}{n} \\right)^n \\qquad (1) } 例子： 显示： \\bbox[#9ff, 5px]{ e^x=\\lim_{n\\to\\infty} \\left( 1+\\frac{x}{n} \\right)^n \\qquad (1) } 例子： 显示：$$\\bbox[#2f3542, 0.5em, border:2px solid #f1f2f6]{ \\color "},{"title":"激光SLAM学习 深蓝学院课程 简介","date":"2022-10-21T13:04:11.857Z","url":"/2022/10/21/SLAM/0_Introduction/","tags":[["AI","/tags/AI/"],["Deep learning","/tags/Deep-learning/"],["SLAM","/tags/SLAM/"]],"categories":[["undefined",""]],"content":"简介这是有关激光雷达SLAM的学习，其核心是利用激光雷达传感器以及内置的其他传感器，对周围环境进行构建地图并定位激光雷达所在坐标，即同步定位和建图（Simultaneous Localization and Mapping，SLAM），其流程框架如下图。 整体分为三个部分： • 前端匹配：通过观测点云与目标点云进行匹配得到相对位姿 目标点云：建图时为首帧，定位时为已有地图 • 匹配关键帧：在所有前端匹配帧中，选取最优的作为关键帧 • 后端优化：利用其他传感器进行约束和计算，优化生成地图 前端里程计在课程中的介绍，前端里程计的作用是为了将当前点云与已存在点云进行相对位姿的计算，在当前点云: 在当前时刻帧，激光雷达对周围环境采集的点云已存在点云 ：上一帧或已建成地图的点云课程中介绍了多种前端里程计基本算法，分别为以下： 基于直接匹配的方法：整体点云直接匹配，包括ICP（Iterative Closest Point），NDT（Normal Distribution Transformation）等 基于特征：LOAM, A-LOAM, F-LOAM, LEGO-LOAM 多传感器融合里程计： LINS, LIO-SAM, LIO-mapping 基于栅格： cartographer 基于面元： suma 基于语义： segmap, suma++ 其中课程中主要对前三个进行讲解和分析，并给出实现代码和运行框架。 在其他文章中，对其前端里程计基本算法进行学习和笔记记录，包括公式推导和代码讲解。"},{"title":"深度学习笔记","date":"2022-10-19T13:45:39.211Z","url":"/2022/10/19/DeepLearningByAndrewNg/","tags":[["AI","/tags/AI/"],["Deep learning","/tags/Deep-learning/"]],"categories":[["undefined",""]],"content":"Stanford CS230(吴恩达 深度学习 Deep Learning | Autumn 2018)笔记第零课深度学习是什么？深度学习一般与神经网络是一个同义词，Deep Learning简称DL，与传统的Machine Learning(ML)不同，但是是ML的一部分，也是最难的一部分。 深度学习兴起主要是由于互联网发展以及GPU计算的能力提升，更多数据被电子化以及计算力的大幅提升，使得神经网络变得更大更能解决更多数据带来的问题和潜在的有价值的东西。 一个好的AI团队需要什么？ 团队一般具备各种数据采集能力 团队能通过深度学习来对数据进行分析 普遍的自动化 本课程含五个Courses： 什么是神经元？什么是神经网络层？如何将他们堆叠起来搭建神经网络？ 如何调整(tune)这些神经网络？如何改进神经网络的效果？ 机器学习项目的开发流程 卷积神经网络(CNN Convolutional Neural Network) 序列模型(Sequence Model)如递归神经网络(Recurrent Neural Network) 参考课程视频：对于2中的每一个视频，先到1中看了视频在看2，效果会好一些 2中视频备注如C1M1，代表第一个Courses(一共上面5个),每个有很多modules，一般一个视频两个modules Courses In-class 第一课神经网络的有监督学习建立y(y1,y2…)到x(x1,x2,x3,x4…)的映射关系，我们给出数据包含(x,y)对神经网络进行训练，找到最佳的参数来表达y和x之间的关系。 有监督学习的x输入结构化数据：表格类型的，矩阵类型的数据非结构化数据：声音，图像，文本等 神经网络基础神经网络包含前向过程(forward propagation) 和 反向传播过程(backward propagation)即BP 简单的二元逻辑回归例子 问题模型描述：输入x∈Rnx，是输出y则是label∈{0,1},一共有m个训练样本{(x1,y1),(x2,y2)…(xm,ym)} 对于训练样本的m个输入x，进行堆叠为一个nx × m的矩阵，y同样为1 x m的矩阵 在这里我们使用$\\hat{y}$表示通过算法预测的结果，我们需要它与y形成一个概率的关系，即取值为{0~1},由于直接使用线性函数去拟合，我们输出只有0~1的情况下，有可能会输出负数,或者超过1，这里我们使用一个叫sigmoid函数对线性拟合处理，sigmoid表示为如下 $\\frac{1}{1+e^{-z}}$, 原来y = wTx + b表示为y = $\\delta$ (wTx + b) 梯度下降上述损失函数很好地描述了w和b对Y和$\\hat{y}$之间的的关系，但是我们要得到更好地使得J(w,b)更小，在这里我们提出梯度下降法来求解w和b使得J(w,b)最小。 神经网络的理解 如上图，神经网络可以理解为是一个黑箱，函数，输入图像，经过结构和参数得到里面是否有猫，有=1，无=0，这是一个基本的神经网络的模式。 神经网络模型 = 结构 + 参数 我们的目标就是要找到在结构中最佳的参数来的到最好的结果，我们可以改变这个模式中的很多东西： 输入input，将图片换成其他的数据格式 输出output，改变求解问题，如要求猫的种类(多类分类)，猫的年龄(线性回归) 损失函数Loss function，根据与真值的比较定义的误差来更新 结构Architecture，一般以结构来命名神经网络如循环神经网络，卷积神经网络等 激活函数Activation function， 优化器Optiomizer, 超参数Hyperparameters，如学习率,优先的批处理等外部设置的参数 其中几个例子一、分类问题问题描述：给一张图片，要分辨出是猫或不是猫（白天或黑夜）问题分析： 输入：表示为像素矩阵的图片(二维矩阵) 输出：类型（猫或非猫） 损失函数：二元逻辑回归，目标是猫（0），不是猫是(1)，设置阈值如(0.5) 结构：有很多如CNN,RCNN等 激活函数：使用sigmoid函数，使得输出保持在0~1之间 如果是多分类问题（分类几种动物）有以下几个解决方法： 单热编码，这样能在一张图片上同时出现两种动物，但这样需要使用softmax激活函数。 训练多神经网络，每一个对应一种动物，这样效率不高不能有效利用。 训练时，需要输入多张带标签的动物图片，在训练时进行带标签（编码）的训练 二、人像识别问题描述：输入人脸后，需要知道是不是对应学生（id）的问题分析： 输入: 表示为像素矩阵的图片(二维矩阵) 输出：判断是否为指定的学生，二分类，设置阈值 损失函数：输入的待认证图像与图像库中的图像进行匹配，向量化的差值基本与上面相同，但比较先进的人脸识别方法应该不是这样的，有一定的改进但总体思路是一样的。 三、风格转移问题描述：给出一张图片的内容和另一张图片的风格，生成1图片内容含2图片风格问题分析： 数据：目标content和目标style图 输入：随机白噪声或带偏置的图（或其他的） 输出：含有content和style的图 损失函数：生成的图片同时与content之间的内容差值和style图之间的style差值 四、语音识别问题描述：给出一段语音，识别出其中的激活词问题分析： 数据：很多包含或不包含（正负样本）激活词的样本集，有两种方式： ①：找很多人录音，手动标记； ②：收集正样本和负样本插入到背景噪音中，可以程序化生成样本并自动标记 输入：一段待识别的语音 输出：对每个时序输出0或1来识别激活词 损失函数：编码后的语音与激活词之间的距离 结构：RNN，LSTM结构 虽然以上方法很好地定义了其中很多内容，但关键影响效果的是结构和它的参数调整能否有效"},{"title":"有关一些文件处理","date":"2022-10-19T13:45:39.158Z","url":"/2022/10/19/tools/DataFile%20Dealing/","categories":[["undefined",""]],"content":"Introduction由于利用mahjong-helper处理麻将牌谱,整理一下几种人工智能数据格式在python中的处理方式。 xls和xlsxpython中对于这两种文件有三个库可以用，xlwt，xlrd和openpyxl，这里以xlrd为例，其他两个大同小异。 excel文档有三个概念，workbook(文档)，sheet(表单)，cell(单元格)，以下是一个demo遍历每一个单元格： csvcsv跟上面的不一样，它默认有表头，并且只能存一张表，用的是pandas的read_csv函数来读的，返回的是pandas的DataFrame对象。 hdf5这个是最复杂的文件结构，它用的是类Unix的文件组织结构来组织文件。在python中用的是h5py的库"},{"title":"Mahjong AI","date":"2022-10-19T13:45:38.565Z","url":"/2022/10/19/mahjong%20AI/","tags":[["AI","/tags/AI/"],["日麻","/tags/%E6%97%A5%E9%BA%BB/"]],"categories":[["undefined",""]],"content":"简介这是一个关于日本麻将人工智能算法的笔记，期望以后能进行推进开发实用。 相关文献 NaoKi Mizukami 水上直紀 多人数性を分割した教師付き学習による四人麻雀プログラムの実現原版 中文版 NaoKi Mizukami 水上直紀 Building a Computer Mahjong Player Based on Monte Carlo Simulation and Opponent Models原版 中文版 NaoKi Mizukami 水上直紀 期待最終順位に基づくコンピュータ麻雀プレイヤの構築原版 Ryouhei KITAGAWA 北川竜平 麻雀の牌譜からの打ち手評価関数の学習原版 NaoKi Mizukami 水上直紀 牌譜を用いた対戦相手のモデル化とモンテカルロ法によるコンピュータ麻雀プレイヤの構築 NaoKi Mizukami 水上直紀 強化学習を用いた効率的な和了を行う麻雀プレイヤ NaoKi Mizukami 水上直紀 多人数不完全情報ゲームにおける仮想自己対戦を用いた強化学習 NaoKi Mizukami 水上直紀 降りるべき局面の認識による1 人麻雀プレイヤの4 人麻雀への適用 感谢译者 零之审判(北京大学数学科学学院 学士毕业) 译者注 译者关于这几篇论文的看法以及理解，很值得一看 感谢本博客基于的是mahjong-helper的代码。该平台支持天凤和雀魂，查看和分析牌谱，实时获取当前数据，并进行分析，同时跨平台支持linux，windows和mac。~日麻杂谈群375865038~ 我在其中添加该算法，使用的是该平台的雀魂平台上进行试验。 日本麻将术语暂时不写了，是日麻基本规则 基于有监督的单人麻将程序 这部分讲述三篇水上直紀大佬写的三篇文章中，关于单人麻将的算法以及它们的基本原理，本人理解有限，希望能复现他们的工作(希望能改进)。 单人麻将的规则所以基本就是一直摸切摸切，有点像第一代雀魂的AI，不会鸣牌(因为单人麻将不能鸣牌)，一直摸直到流局或立直。 基于平均感知器的算法这是第一篇文章中的单人麻将的算法，利用的是基于平均感知器的算法来减少向听达成自摸。平均感知器是基于条件随机场的的全局化以最大熵准则建模的函数的一个有监督模型。[1] 算法流程文章中使用的特征量提取模型，是用的2007年北川论文中的特征量。引用译者的翻译: 特征类 特征个数 面子手、七对子、国士无双向听数 15+7+14=36 3色（万、筒、索）中不使用n色（n=1˜ 3）的n和向听数 3×16=48 色的个数（1˜ 4）及各色向听数的组合 12+78+364+1365=1819 各色牌中最多的数量 15 各色牌中最多的数量+字牌数 15 2到8的数牌量 15 面子和不含有幺九的连续2张牌的搭子和面子候补的组合 6+12+72=90 各字牌的枚数和役牌的枚数和是否是宝牌的组合 5×6×2=60 数牌的数字-5的绝对值和枚数和是否是宝牌的组合 5×5×2=50 各色牌中是否有1˜ 9的组合 512 连续的n个数牌中各牌数量的组合（n=2˜ 6） 100+500+1860+8634+23760=34854 我们来分析一下某几个特征量是怎么算出来的，例如第一行中的国士无双向听数，最简单的就是0向听˜13向听，那就是一共14种情况，即特征个数。七对子也是0˜7向听等。 对于所有牌谱中的手牌(局面),当轮到主视角时，手牌有14张，我们来计算切掉每一张牌后，剩下的13张牌所组成的特征量的得分。 $f(x,w)=\\sum_{i=1}^{n}x_iw_i$ 一共有14张牌得分，计算出得分最高的切牌$\\widehat{t}$的得分以及实际切牌$t*$的得分，如果不相同则以实际切牌的为准，并更新权重，根据两个切牌的特征向量，原权重加上实际切牌的权重再减去最高得分切牌权重，更新公式如下 $w^{‘}=w+x{t*}-x\\widehat{t}$ 遍历三遍输入训练数据后，输出权重，根据得分最高的来打牌。 有监督训练集由于使用的是牌谱的有监督学习，且是单人麻将，文章中采用的牌谱是天凤凤凰桌所有局中，第一个立直的人直到立直的所有切牌数据作为训练数据，一共有170万个局面(手牌状况)。但是作者并没有公开这些数据，复现这个方法需要大量的牌谱，而且是顶尖选手的牌谱。 攻防判断——识别是否弃和该部分是识别当前的局面是否应该弃和，在这篇文章中，采用的是二分类法，用了SVM的分类器根据局面上提取的特征来判断是否弃和。同时，如果一个局面被标记为弃和后，之后的所有局面都应标记为弃和。而兜牌是不被标记为弃和的，只是进攻的一个手段。 同时文章提及是否弃和是一个比较主观的定义，是有一些局面的判断是非常难判断的。但考虑到人类玩家弃和的思考方式，采用安全度来判断是否弃和： 标记好数据后，使用SVM分类器，判断是否弃和的特征向量如下，共7+3*8+3=34维。 特征类 数量 自身状态 向听数 1 七对子向听数 1 是否立直 1 是否坐庄 1 副露数 1 副露的宝牌数 1 手牌宝牌数 1 对手状态 是否立直 1 副露数 1 副露可见的宝牌数 1 是否坐庄 1 想切的牌对该玩家安全度 4 场上状况 牌山剩余量 1 杠的数量 1 牌河里宝牌数量 1 加入程序鸣牌的能力鸣牌程序训练跟第一部分单人程序大致相同，使用鸣牌局面的牌谱来进行训练，同样使用平均感知器算法来对局面的所有特征向量来分类，下表是跟单人麻将差不多的特征向量： 特征类 特征个数 副露数 5 是否可能立直 2 各色的1˜9数牌数量变换到0，1，2以上的牌型 19472 副露里选择n（1˜2）个副露的种类组合 136+9316=9452 手牌里有3张以上相同牌的数量和2张以上相同牌的数量的组合 5×7=35 手牌里有3张以上相同牌的数量+碰的个数和2张以上相同牌的数量的组合，还有是否吃牌 5×7+1=36 手牌和副露中断幺牌数量和向听数 16+16=32 连续的各色的3张数牌里的有无和3张里是否包含幺九和是否包含吃的组合 512×2×2=2048 包含吃的各色里幺九的有无 512 各色牌中最多的数量+该色和字牌的副露数×3 16 各色牌中最多的数量+字牌个数+该色和字牌的副露数×3 16 做特定色染手的向听数 16 役牌对子数 8 役牌刻子数 6 宝牌个数（0，1，2，3以上）和2˜8数牌中宝牌数量 4+4=8 副露数和向听数的组合 5×15=75 向听数和有役、有门清限定役、没役和巡目的组合 2×3×19=114 有役和是否是门清限定役和没有役 3 是否鸣了幺九牌和加入幺九牌时向听数减少的量（0，1，2以上） 2×3=6 手牌里不使用幺九牌的向听数增加的量（0，1，2以上） 3 加上所有副露的风牌后其数量（0，1，2，3以上）的组合 4×4×4×4=256 加上所有副露的三元牌后其数量（0，1，2，3以上）的组合 4×4×4=64 副露数和向听数和加入已经切出的牌是否减少向听数的组合 5×4×2=40 结合单人麻将，攻防判断和鸣牌打法有了不鸣牌，攻防判断以及鸣牌的打法，就可以基本训练出电脑程序打麻将的逻辑所有部分 结合前面三个部分可以完成这个流程，完成打麻将的策略。 总结这个论文的程序基本提供了一种有监督的方法来训练程序对门清状态的打牌，攻防判断和鸣牌的打法学习。但仍有很多不足，在文中认为弃和后，不会再次副露。训练集都是能和牌的局面，那么在手牌难以和牌的时候进行错误鸣牌，文中也说能通过在训练样本中加入没有和牌的局面解决。 References [1]: 平均感知器  [2]: 手牌特征量分析 北川竜平、三輪 誠 、近山 隆. 麻雀の牌譜からの打ち手評価関数の学習. Proceedings of the 12thGame Programming Workshop, 2007"}]